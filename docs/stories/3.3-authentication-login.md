# Story 3.3: Authentication & Login

**Story ID:** 3.3
**Assigned to:** @dev
**Sprint:** Sprint 4 (Week 6)
**Status:** Draft
**Estimation:** 5 story points (2-3 days)

---

## Summary

Implement complete authentication flow with login page, JWT token handling, protected routes, user context management, and logout functionality. Provides secure access control for the DecisionLog dashboard.

---

## UX Research Context

This story provides **secure, frictionless access** to DecisionLog and directly impacts user experience:

**Secure Access for Sensitive Information**
- DecisionLog contains **confidential decision-making records** (architectural decisions, budget impacts, team consensus)
- **Bad security = Data breaches, loss of trust**
- **Good security = Users feel confident sharing sensitive decisions**
- JWT tokens via HTTP-only cookies prevent token theft from JavaScript
- Auto-logout on 401 (compromised token) protects user accounts

**Low-Friction Login Experience**
- Users should log in once, stay logged in across sessions
- **Bad login UX = Repeated logins = Abandoned product**
- **Good login UX = Seamless access, users return**
- Session persistence (remember login via localStorage/sessionStorage)
- Password visibility toggle (show/hide) reduces typos
- Clear error messages for wrong credentials (not cryptic "401 Error")

**Psychological Safety for Architecture Teams**
- Gabriela & Architects need to feel **safe recording disagreements** and concerns
- If authentication is clunky/distracting, users avoid the system
- **Good auth = Invisible, doesn't get in the way**
- **Bad auth = Users forget passwords, abandon product**

**Mobile Accessibility (Gabriela's Use Case)**
- Gabriela logs in on iPhone/iPad during work (not at desk)
- Password visibility toggle critical on mobile (harder to verify what you typed)
- Form fields must work with mobile keyboard
- Touch-friendly button size (≥44px per WCAG)

**Reference:** Enables all frontend stories (Timeline, Filters, Digest, Drill-down) to work securely

---

## Acceptance Criteria

### Login Page Component (UX: Frictionless Access)
- [ ] Login page (`src/pages/Login.tsx`) created with Shadcn/ui components
- [ ] Page layout:
  - [ ] Centered card on light background (Shadcn/ui Card styling)
  - [ ] DecisionLog logo/heading (text-3xl font-bold)
  - [ ] Subtitle: "Sign in to your account"
  - [ ] Form with email + password inputs
- [ ] Email input:
  - [ ] `<Input type="email">` (Shadcn/ui Input component)
  - [ ] Label: "Email address" (Shadcn/ui Label)
  - [ ] Placeholder: "you@example.com"
  - [ ] Validation: `required` attribute
  - [ ] Auto-complete: `autoComplete="email"`
- [ ] Password input:
  - [ ] `<Input type={showPassword ? 'text' : 'password'}>` (toggle visibility)
  - [ ] Label: "Password" (Shadcn/ui Label)
  - [ ] Placeholder: "••••••••" (dots)
  - [ ] Visibility toggle button (Show/Hide text)
  - [ ] Auto-complete: `autoComplete="current-password"`
  - [ ] **UX:** Password visibility toggle critical for mobile (harder to see what you typed on small screens)
- [ ] Submit button:
  - [ ] Shadcn/ui Button component
  - [ ] Label: "Sign in"
  - [ ] Type: `submit`
  - [ ] Full width: `className="w-full"`
  - [ ] **Loading state:** Button disabled + label changes to "Signing in..." during API request (UX: indicates action in progress)
  - [ ] **Disabled when:** Email empty OR password empty (form validation)
  - [ ] Touch-friendly: ≥44px height (WCAG 2.5.5, mobile accessibility)
- [ ] Error message display:
  - [ ] Shadcn/ui Alert (variant=destructive, red color)
  - [ ] Shows **friendly error message** from API (Story 3.2):
    - "Invalid credentials" (wrong email/password)
    - "Authentication required" (if token expired)
    - "Network error" (if API unreachable)
  - [ ] **Not** cryptic codes like "401" or "Invalid username/password combination"
- [ ] Form submission:
  - [ ] `<form onSubmit={handleSubmit}>`
  - [ ] Prevents default form submission (`e.preventDefault()`)
  - [ ] Calls `api.login({ email, password })`

### Authentication Flow (Security + UX)
- [ ] Login API integration:
  - [ ] Call `api.login({ email, password })` on form submit
  - [ ] Uses React Query `useMutation` to manage async state
  - [ ] Loading state: `loginMutation.isPending` (button disabled)
  - [ ] Error state: `loginMutation.isError` (show alert)
  - [ ] Success state: User info received
- [ ] JWT token handling (via API Service Layer, Story 3.2):
  - [ ] Backend returns JWT in HTTP-only cookie (`Set-Cookie: access_token=...`)
  - [ ] JWT automatically sent in all subsequent requests (Story 3.2 `withCredentials: true`)
  - [ ] Frontend never accesses token directly (secure)
- [ ] User state management (Zustand):
  - [ ] On login success: `setUser(response.user)` → Update auth store with user data
  - [ ] User info includes: `id`, `email`, `name`, `role`
  - [ ] Auth state: `isAuthenticated = !!user` (user exists = authenticated)
- [ ] Navigation on success:
  - [ ] On login success: Redirect to `/projects` page (Projects List, Story 3.4)
  - [ ] Use `useNavigate()` hook: `navigate('/projects')`
  - [ ] Replace history (no back button to login)
- [ ] Error handling:
  - [ ] On login failure: Show error message (Shadcn/ui Alert)
  - [ ] User stays on login page, can retry
  - [ ] Clear password field (for security, don't repeat password on retry)

### Protected Routes (Security: Access Control)
- [ ] ProtectedRoute component (`src/components/ProtectedRoute.tsx`):
  - [ ] HOC (Higher-Order Component) wrapping protected pages
  - [ ] Takes `children` prop (page component to protect)
  - [ ] Returns either: protected page (authenticated) OR redirect to login (not authenticated)
- [ ] Authentication check:
  - [ ] On mount: Check if `isAuthenticated` from auth store
  - [ ] If not authenticated: Try to fetch current user via `api.getCurrentUser()`
  - [ ] Uses React Query to manage fetch state
  - [ ] `enabled: !isAuthenticated` (only fetch if not already logged in)
- [ ] Loading state:
  - [ ] While checking auth: Show spinner + "Loading..." message
  - [ ] Centered on screen, min-h-screen (full height)
  - [ ] Prevents flash of login page on page refresh
- [ ] Redirect logic:
  - [ ] If authenticated: Render `children` (protected page)
  - [ ] If error or not authenticated: Redirect to `/login`
  - [ ] Use React Router `<Navigate to="/login" replace />`
  - [ ] **UX:** `replace` prevents back button to protected page when logged out
- [ ] Route configuration:
  - [ ] All protected pages wrapped: `/projects`, `/projects/:id`
  - [ ] Login page NOT protected
  - [ ] Root `/` redirects to `/projects` (authenticated) or login (not authenticated)

### Navigation Header with Logout (UX: Clear Exit Path)
- [ ] Header component (`src/components/Header.tsx`):
  - [ ] Appears on all protected pages (Projects, Timeline, Digest, etc.)
  - [ ] Shows DecisionLog logo + user menu
  - [ ] Responsive: Navigation works on mobile/tablet/desktop
- [ ] Header layout:
  - [ ] Logo/branding: "DecisionLog" (text-xl font-bold, blue color)
  - [ ] User info: Display `user.name` (current logged-in user)
  - [ ] User menu dropdown (Shadcn/ui DropdownMenu):
    - [ ] Trigger: User icon button (lucide-react `User` icon)
    - [ ] Menu content: User email + Logout button
    - [ ] Separator line between label and action
- [ ] Logout functionality:
  - [ ] Logout button in dropdown menu
  - [ ] Click → Call `api.logout()` via React Query mutation
  - [ ] On success (or error): Clear auth state + navigate to login
  - [ ] **Loading state:** Button shows "Logging out..." while API call in progress
  - [ ] **UX:** Clear feedback that logout is happening (not instant)
- [ ] Logout flow:
  - [ ] `api.logout()` calls backend `/api/auth/logout` endpoint
  - [ ] Backend clears session/token on server-side
  - [ ] Frontend: `logout()` from auth store (clears user + isAuthenticated)
  - [ ] **Security:** Cookie automatically cleared via `Set-Cookie: access_token=; Max-Age=0;`
  - [ ] Redirect to `/login` after logout
  - [ ] **UX:** No sensitive data left in browser after logout

### Session Persistence (UX: Stay Logged In)
- [ ] Zustand auth store with persistence middleware:
  - [ ] Use `zustand/middleware` → `persist()` wrapper
  - [ ] Stores auth state in **localStorage** (survives page refresh)
  - [ ] Key: `auth-storage` (or similar)
- [ ] Persistence data:
  - [ ] Store: `user` object + `isAuthenticated` boolean
  - [ ] Load on app start: Auto-restore user from localStorage
  - [ ] **UX:** Users don't need to log in again after page refresh (frictionless)
- [ ] Token validity check:
  - [ ] On app mount (ProtectedRoute): Call `api.getCurrentUser()`
  - [ ] If token expired: API returns 401 → API client auto-logs out (Story 3.2)
  - [ ] If token valid: User data refreshed from backend
  - [ ] **Security:** Stale tokens don't grant access
  - [ ] **UX:** App always has fresh user data

### Password Visibility Toggle (UX: Mobile Accessibility)
- [ ] Show/Hide button on password field:
  - [ ] Button positioned inside password input (right side)
  - [ ] Text label: "Show" or "Hide" (user understands action)
  - [ ] **Accessibility:** Button type="button" (not submit)
  - [ ] **Mobile:** Touch-friendly size ≥44px (WCAG)
  - [ ] **UX:** Reduces typos on mobile (harder to see what you typed on small screen)

### Responsive Design (Mobile-First)
- [ ] Login page responsive:
  - [ ] Desktop: Centered card (max-w-md = 448px)
  - [ ] Tablet/Mobile: Full width with padding (px-4)
  - [ ] Touch-friendly: All buttons ≥44px height
  - [ ] Form fields adapt to mobile keyboard
- [ ] Header responsive:
  - [ ] Desktop: Logo left, user menu right
  - [ ] Mobile: Same layout, hamburger menu optional (Phase 2)
  - [ ] Touch-friendly: Dropdown button easy to tap

### Error Handling & User Feedback
- [ ] Login errors (from Story 3.2 error handling):
  - [ ] **Wrong credentials:** "Invalid email or password"
  - [ ] **Account doesn't exist:** "No account found with that email"
  - [ ] **Network error:** "Network error. Check your internet connection."
  - [ ] **Server error:** "Server error. Please try again later."
  - [ ] **Rate limited:** "Too many login attempts. Please try again later."
- [ ] Logout errors:
  - [ ] If logout API fails: Show error in dropdown
  - [ ] Still clear local auth state (logout client-side)
  - [ ] Redirect to login even if API call fails (don't trap user)

### Testing
- [ ] Unit tests >80% coverage:
  - [ ] Login page renders (email, password, button fields)
  - [ ] Form submission calls `api.login()`
  - [ ] Loading state shows during request
  - [ ] Error message displays on failed login
  - [ ] Success redirects to `/projects`
  - [ ] Password visibility toggle works
  - [ ] ProtectedRoute redirects unauthenticated users to login
  - [ ] ProtectedRoute shows loading spinner while checking auth
  - [ ] Logout button calls `api.logout()`
  - [ ] Auth state persists across page refresh (localStorage)
- [ ] Integration test: Full login → navigate → logout flow
- [ ] Accessibility test: Keyboard navigation (Tab through fields), Screen reader (form labels)
- [ ] Mobile test: Form works on iPhone (375px), iPad (768px)

---

## Tasks

### Task 1: Create Login Page Component (1 day)

1. **Create `src/pages/Login.tsx`**
   ```typescript
   import { useState, FormEvent } from 'react'
   import { useNavigate } from 'react-router-dom'
   import { useMutation } from '@tanstack/react-query'
   import { api } from '../services/api'
   import { useAuthStore } from '../store/authStore'
   import { getErrorMessage } from '../lib/errors'
   import { Button } from '../components/ui/button'
   import { Input } from '../components/ui/input'
   import { Label } from '../components/ui/label'
   import { Alert, AlertDescription } from '../components/ui/alert'

   export function LoginPage() {
     const [email, setEmail] = useState('')
     const [password, setPassword] = useState('')
     const [showPassword, setShowPassword] = useState(false)
     const navigate = useNavigate()
     const setUser = useAuthStore((state) => state.setUser)

     const loginMutation = useMutation({
       mutationFn: () => api.login({ email, password }),
       onSuccess: (response) => {
         setUser(response.user)
         navigate('/projects')
       },
     })

     const handleSubmit = (e: FormEvent) => {
       e.preventDefault()
       if (!email || !password) return
       loginMutation.mutate()
     }

     return (
       <div className="min-h-screen flex items-center justify-center bg-gray-50">
         <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow-md">
           <div>
             <h2 className="text-3xl font-bold text-center">DecisionLog</h2>
             <p className="mt-2 text-center text-gray-600">
               Sign in to your account
             </p>
           </div>

           <form onSubmit={handleSubmit} className="space-y-6">
             <div>
               <Label htmlFor="email">Email address</Label>
               <Input
                 id="email"
                 name="email"
                 type="email"
                 autoComplete="email"
                 required
                 value={email}
                 onChange={(e) => setEmail(e.target.value)}
                 className="mt-1"
                 placeholder="you@example.com"
               />
             </div>

             <div>
               <Label htmlFor="password">Password</Label>
               <div className="relative mt-1">
                 <Input
                   id="password"
                   name="password"
                   type={showPassword ? 'text' : 'password'}
                   autoComplete="current-password"
                   required
                   value={password}
                   onChange={(e) => setPassword(e.target.value)}
                   placeholder="••••••••"
                 />
                 <button
                   type="button"
                   onClick={() => setShowPassword(!showPassword)}
                   className="absolute right-2 top-2 text-gray-500 hover:text-gray-700"
                 >
                   {showPassword ? 'Hide' : 'Show'}
                 </button>
               </div>
             </div>

             {loginMutation.isError && (
               <Alert variant="destructive">
                 <AlertDescription>
                   {getErrorMessage(loginMutation.error)}
                 </AlertDescription>
               </Alert>
             )}

             <Button
               type="submit"
               className="w-full"
               disabled={loginMutation.isPending || !email || !password}
             >
               {loginMutation.isPending ? 'Signing in...' : 'Sign in'}
             </Button>
           </form>
         </div>
       </div>
     )
   }
   ```

2. **Install Shadcn/ui components**
   ```bash
   npx shadcn-ui@latest add button
   npx shadcn-ui@latest add input
   npx shadcn-ui@latest add label
   npx shadcn-ui@latest add alert
   ```

### Task 2: Implement Protected Routes (0.5 days)

1. **Create `src/components/ProtectedRoute.tsx`**
   ```typescript
   import { ReactNode, useEffect } from 'react'
   import { Navigate, useLocation } from 'react-router-dom'
   import { useQuery } from '@tanstack/react-query'
   import { useAuthStore } from '../store/authStore'
   import { api } from '../services/api'

   interface Props {
     children: ReactNode
   }

   export function ProtectedRoute({ children }: Props) {
     const location = useLocation()
     const { user, setUser, isAuthenticated } = useAuthStore()

     // Try to fetch current user if not authenticated
     const { data, isLoading, isError } = useQuery({
       queryKey: ['currentUser'],
       queryFn: () => api.getCurrentUser(),
       enabled: !isAuthenticated,
       retry: false,
     })

     useEffect(() => {
       if (data) {
         setUser(data)
       }
     }, [data, setUser])

     if (isLoading) {
       return (
         <div className="min-h-screen flex items-center justify-center">
           <div className="text-center">
             <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
             <p className="mt-4 text-gray-600">Loading...</p>
           </div>
         </div>
       )
     }

     if (isError || !isAuthenticated) {
       // Redirect to login, preserving the attempted location
       return <Navigate to="/login" state={{ from: location }} replace />
     }

     return <>{children}</>
   }
   ```

2. **Update Router with protected routes**
   ```typescript
   // src/Router.tsx
   import { Routes, Route, Navigate } from 'react-router-dom'
   import { LoginPage } from './pages/Login'
   import { ProjectsPage } from './pages/Projects'
   import { ProjectDetailPage } from './pages/ProjectDetail'
   import { ProtectedRoute } from './components/ProtectedRoute'

   export function Router() {
     return (
       <Routes>
         <Route path="/login" element={<LoginPage />} />

         <Route
           path="/projects"
           element={
             <ProtectedRoute>
               <ProjectsPage />
             </ProtectedRoute>
           }
         />

         <Route
           path="/projects/:id"
           element={
             <ProtectedRoute>
               <ProjectDetailPage />
             </ProtectedRoute>
           }
         />

         <Route path="/" element={<Navigate to="/projects" replace />} />
       </Routes>
     )
   }
   ```

### Task 3: Create Navigation Header with Logout (0.5 days)

1. **Create `src/components/Header.tsx`**
   ```typescript
   import { useNavigate } from 'react-router-dom'
   import { useMutation } from '@tanstack/react-query'
   import { useAuthStore } from '../store/authStore'
   import { api } from '../services/api'
   import { Button } from './ui/button'
   import {
     DropdownMenu,
     DropdownMenuContent,
     DropdownMenuItem,
     DropdownMenuLabel,
     DropdownMenuSeparator,
     DropdownMenuTrigger,
   } from './ui/dropdown-menu'
   import { User } from 'lucide-react'

   export function Header() {
     const navigate = useNavigate()
     const { user, logout } = useAuthStore()

     const logoutMutation = useMutation({
       mutationFn: () => api.logout(),
       onSettled: () => {
         logout()
         navigate('/login')
       },
     })

     const handleLogout = () => {
       logoutMutation.mutate()
     }

     return (
       <header className="bg-white border-b border-gray-200">
         <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
           <div className="flex justify-between items-center h-16">
             <div className="flex items-center">
               <h1 className="text-xl font-bold text-blue-600">DecisionLog</h1>
             </div>

             <div className="flex items-center gap-4">
               <span className="text-sm text-gray-600">{user?.name}</span>

               <DropdownMenu>
                 <DropdownMenuTrigger asChild>
                   <Button variant="ghost" size="icon">
                     <User className="h-5 w-5" />
                   </Button>
                 </DropdownMenuTrigger>

                 <DropdownMenuContent align="end">
                   <DropdownMenuLabel>
                     {user?.email}
                   </DropdownMenuLabel>
                   <DropdownMenuSeparator />
                   <DropdownMenuItem onClick={handleLogout}>
                     {logoutMutation.isPending ? 'Logging out...' : 'Logout'}
                   </DropdownMenuItem>
                 </DropdownMenuContent>
               </DropdownMenu>
             </div>
           </div>
         </div>
       </header>
     )
   }
   ```

2. **Install additional Shadcn components**
   ```bash
   npx shadcn-ui@latest add dropdown-menu
   npm install lucide-react
   ```

### Task 4: Add Session Persistence (0.5 days)

1. **Update auth store with persistence**
   ```typescript
   // src/store/authStore.ts
   import { create } from 'zustand'
   import { persist } from 'zustand/middleware'
   import { User } from '../types'

   interface AuthState {
     user: User | null
     isAuthenticated: boolean
     setUser: (user: User | null) => void
     logout: () => void
   }

   export const useAuthStore = create<AuthState>()(
     persist(
       (set) => ({
         user: null,
         isAuthenticated: false,
         setUser: (user) => set({ user, isAuthenticated: !!user }),
         logout: () => {
           set({ user: null, isAuthenticated: false })
           document.cookie = 'access_token=; Max-Age=0; path=/;'
         },
       }),
       {
         name: 'auth-storage',
         partialize: (state) => ({
           user: state.user,
           isAuthenticated: state.isAuthenticated,
         }),
       }
     )
   )
   ```

2. **Add token validation on app mount**
   ```typescript
   // src/App.tsx
   import { useEffect } from 'react'
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
   import { BrowserRouter } from 'react-router-dom'
   import { Router } from './Router'
   import { useAuthStore } from './store/authStore'
   import { api } from './services/api'

   const queryClient = new QueryClient({
     defaultOptions: {
       queries: {
         refetchOnWindowFocus: false,
         retry: 1,
         staleTime: 5 * 60 * 1000,
       },
     },
   })

   function App() {
     const { setUser, isAuthenticated } = useAuthStore()

     useEffect(() => {
       // Validate token on mount
       if (isAuthenticated) {
         api.getCurrentUser()
           .then(setUser)
           .catch(() => {
             // Token invalid, logout
             useAuthStore.getState().logout()
           })
       }
     }, [])

     return (
       <QueryClientProvider client={queryClient}>
         <BrowserRouter>
           <Router />
         </BrowserRouter>
       </QueryClientProvider>
     )
   }

   export default App
   ```

### Task 5: Write Tests (0.5 days)

1. **Create `tests/pages/Login.test.tsx`**
   ```typescript
   import { describe, it, expect, vi } from 'vitest'
   import { render, screen, fireEvent, waitFor } from '@testing-library/react'
   import { BrowserRouter } from 'react-router-dom'
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
   import { LoginPage } from '../../src/pages/Login'
   import { api } from '../../src/services/api'

   vi.mock('../../src/services/api')

   const queryClient = new QueryClient({
     defaultOptions: { queries: { retry: false } },
   })

   const wrapper = ({ children }: { children: React.ReactNode }) => (
     <QueryClientProvider client={queryClient}>
       <BrowserRouter>
         {children}
       </BrowserRouter>
     </QueryClientProvider>
   )

   describe('LoginPage', () => {
     it('renders login form', () => {
       render(<LoginPage />, { wrapper })

       expect(screen.getByLabelText(/email/i)).toBeInTheDocument()
       expect(screen.getByLabelText(/password/i)).toBeInTheDocument()
       expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument()
     })

     it('submits form with credentials', async () => {
       const mockLogin = vi.fn().mockResolvedValue({
         user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'director' }
       })
       vi.mocked(api.login).mockImplementation(mockLogin)

       render(<LoginPage />, { wrapper })

       fireEvent.change(screen.getByLabelText(/email/i), {
         target: { value: 'test@example.com' },
       })
       fireEvent.change(screen.getByLabelText(/password/i), {
         target: { value: 'password' },
       })
       fireEvent.click(screen.getByRole('button', { name: /sign in/i }))

       await waitFor(() => {
         expect(mockLogin).toHaveBeenCalledWith({
           email: 'test@example.com',
           password: 'password',
         })
       })
     })

     it('shows error on failed login', async () => {
       vi.mocked(api.login).mockRejectedValue(new Error('Invalid credentials'))

       render(<LoginPage />, { wrapper })

       fireEvent.change(screen.getByLabelText(/email/i), {
         target: { value: 'wrong@example.com' },
       })
       fireEvent.change(screen.getByLabelText(/password/i), {
         target: { value: 'wrong' },
       })
       fireEvent.click(screen.getByRole('button', { name: /sign in/i }))

       await waitFor(() => {
         expect(screen.getByText(/invalid credentials/i)).toBeInTheDocument()
       })
     })

     it('toggles password visibility', () => {
       render(<LoginPage />, { wrapper })

       const passwordInput = screen.getByLabelText(/password/i)
       const toggleButton = screen.getByText(/show/i)

       expect(passwordInput).toHaveAttribute('type', 'password')

       fireEvent.click(toggleButton)
       expect(passwordInput).toHaveAttribute('type', 'text')
       expect(screen.getByText(/hide/i)).toBeInTheDocument()
     })
   })
   ```

2. **Create `tests/components/ProtectedRoute.test.tsx`**
   ```typescript
   import { describe, it, expect, vi } from 'vitest'
   import { render, screen } from '@testing-library/react'
   import { BrowserRouter, Routes, Route } from 'react-router-dom'
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
   import { ProtectedRoute } from '../../src/components/ProtectedRoute'
   import { useAuthStore } from '../../src/store/authStore'

   const queryClient = new QueryClient()

   describe('ProtectedRoute', () => {
     it('renders children when authenticated', () => {
       useAuthStore.setState({
         isAuthenticated: true,
         user: { id: '1', email: 'test@example.com', name: 'Test', role: 'director' }
       })

       render(
         <QueryClientProvider client={queryClient}>
           <BrowserRouter>
             <ProtectedRoute>
               <div>Protected Content</div>
             </ProtectedRoute>
           </BrowserRouter>
         </QueryClientProvider>
       )

       expect(screen.getByText('Protected Content')).toBeInTheDocument()
     })

     it('redirects to login when not authenticated', () => {
       useAuthStore.setState({ isAuthenticated: false, user: null })

       render(
         <QueryClientProvider client={queryClient}>
           <BrowserRouter>
             <Routes>
               <Route path="/login" element={<div>Login Page</div>} />
               <Route
                 path="/"
                 element={
                   <ProtectedRoute>
                     <div>Protected Content</div>
                   </ProtectedRoute>
                 }
               />
             </Routes>
           </BrowserRouter>
         </QueryClientProvider>
       )

       expect(screen.getByText('Login Page')).toBeInTheDocument()
     })
   })
   ```

---

## Dev Notes

### Authentication Flow

```
1. User enters credentials → LoginPage
2. POST /api/auth/login → Backend
3. Backend validates → Returns JWT in cookie + user info
4. Frontend stores user in Zustand
5. Redirect to /projects
6. ProtectedRoute checks authentication
7. If valid → Render content
8. If invalid → Redirect to /login
```

### Token Storage

- **Primary**: HTTP-only cookie (set by backend)
- **Fallback**: Authorization header (if cookie not available)
- **User data**: Zustand store with localStorage persistence

### Session Management

- Token expires after 24 hours (configured in backend)
- Auto-logout on 401 error
- Validate token on app mount
- Persist user data across page refreshes

---

## File List

**Modified/Created:**
- `src/pages/Login.tsx` (new) - Login page component
- `src/components/ProtectedRoute.tsx` (new) - Protected route wrapper
- `src/components/Header.tsx` (new) - Navigation header with logout
- `src/store/authStore.ts` (modify) - Add persistence
- `src/Router.tsx` (modify) - Add protected routes
- `src/App.tsx` (modify) - Add token validation
- `tests/pages/Login.test.tsx` (new) - Login tests
- `tests/components/ProtectedRoute.test.tsx` (new) - Protected route tests
- `package.json` (modify) - Add zustand persistence, lucide-react

---

## Testing Strategy

### Unit Tests

```typescript
// Test coverage areas:
- ✅ Login form rendering
- ✅ Form submission with valid credentials
- ✅ Error handling on failed login
- ✅ Password visibility toggle
- ✅ Protected route access control
- ✅ Redirect behavior
- ✅ Session persistence
- ✅ Logout functionality
```

### Manual Testing

```bash
# Test login flow
1. Start dev server: npm run dev
2. Navigate to /projects (should redirect to /login)
3. Enter invalid credentials (should show error)
4. Enter valid credentials (should redirect to /projects)
5. Refresh page (should stay logged in)
6. Click logout (should redirect to /login)
7. Try to access /projects (should redirect to /login)
```

### Coverage Target

- Minimum: 80%
- Target: 90%+
- Run: `npm run test -- --coverage`

---

## UX Design System References

**Why Authentication Matters for UX:**
- **Frictionless Access:** Session persistence (stay logged in) reduces friction
- **Mobile Accessibility:** Password visibility toggle prevents typos on small screens
- **Clear Errors:** User-friendly error messages build trust (not cryptic codes)
- **Psychological Safety:** Secure auth helps team feel safe recording disagreements
- **Accessibility:** Keyboard navigation, proper labels for screen readers (WCAG AA)

**Shadcn/ui Components Used:**
- Input: https://ui.shadcn.com/docs/components/input (email, password fields)
- Label: https://ui.shadcn.com/docs/components/label (form labels)
- Button: https://ui.shadcn.com/docs/components/button (login, logout buttons)
- Alert: https://ui.shadcn.com/docs/components/alert (error messages)
- DropdownMenu: https://ui.shadcn.com/docs/components/dropdown-menu (user menu)
- Card: https://ui.shadcn.com/docs/components/card (login form container)

**Mobile Accessibility (Gabriela's Use Case):**
- Password visibility toggle critical for mobile (can't easily see what you typed)
- Touch-friendly buttons (≥44px) - Gabriela logs in on iPhone
- Form fields must work with mobile keyboard (don't overlap)
- Responsive layout (login card scales to mobile screens)

---

## Change Log

| Date | Change |
|------|--------|
| 2026-02-08 | Created story |
| 2026-02-08 | Updated with UX context (frictionless access, mobile accessibility, security, error handling) |

---

**Related Stories:** 3.2 (API Service Layer - login uses API), 3.1 (Frontend Setup), 3.4 (Projects List)
**Blocked By:** 3.1 (Frontend Setup), 3.2 (API Service Layer)
**Blocks:** All frontend stories (3.4, 3.5, 3.6, 3.7, 3.8 - all require login to access)
