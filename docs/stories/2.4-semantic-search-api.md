# Story 2.4: Semantic Search API

**Story ID:** 2.4
**Assigned to:** @dev
**Sprint:** Sprint 3 (Week 5)
**Status:** Draft
**Estimation:** 5 story points (2 days)

---

## Summary

Create a semantic search API endpoint that allows users to search decisions by meaning, not just keywords. Uses vector similarity search with pgvector to find decisions similar to a natural language query.

---

## Acceptance Criteria

- [ ] Endpoint created: `GET /api/projects/{project_id}/decisions/search`
- [ ] Query parameters supported:
  - [ ] `q` (required): Search query text
  - [ ] `similarity_threshold` (optional): Minimum similarity score (default: 0.7)
  - [ ] `discipline` (optional): Filter by discipline
  - [ ] `limit` (optional): Results per page (default: 10, max: 100)
  - [ ] `offset` (optional): Pagination offset (default: 0)
- [ ] Returns: Similar decisions with similarity scores (0.0-1.0)
- [ ] Performance: <500ms query time for 1000 decisions
- [ ] Results sorted by similarity (highest first)
- [ ] Pagination working correctly
- [ ] Discipline filtering works with semantic search
- [ ] Empty results handled gracefully
- [ ] Tests passing: `pytest tests/unit/test_semantic_search.py` (80%+ coverage)

---

## Tasks

### Task 1: Create Semantic Search Endpoint (0.75 days)

1. **Define endpoint in FastAPI**
   ```python
   # app/api/decisions.py
   @router.get("/projects/{project_id}/decisions/search")
   async def search_decisions(
       project_id: str,
       q: str = Query(..., min_length=3, description="Search query"),
       similarity_threshold: float = Query(0.7, ge=0.0, le=1.0),
       discipline: Optional[str] = Query(None),
       limit: int = Query(10, ge=1, le=100),
       offset: int = Query(0, ge=0),
       current_user: User = Depends(get_current_user)
   ):
       """
       Search decisions by semantic similarity.

       Returns decisions similar to the query, ordered by similarity score.
       """
   ```

2. **Add request validation**
   - Query must be at least 3 characters
   - Similarity threshold: 0.0 to 1.0
   - Limit: 1 to 100
   - Offset: >= 0

3. **Add authorization check**
   - Verify user has access to project
   - Return 403 if unauthorized

### Task 2: Implement Vector Search Logic (1 day)

1. **Generate query embedding**
   ```python
   from app.utils.embeddings import EmbeddingService

   embedder = EmbeddingService()
   query_embedding = embedder.embed_text(q)
   ```

2. **Query database with vector similarity**
   ```python
   from sqlalchemy import text

   sql = text("""
       SELECT
           id,
           decision_statement,
           who,
           timestamp,
           discipline,
           why,
           causation,
           impacts,
           consensus,
           confidence,
           created_at,
           1 - (embedding <=> :query_embedding::vector) as similarity_score
       FROM decisions
       WHERE project_id = :project_id
           AND embedding IS NOT NULL
           AND 1 - (embedding <=> :query_embedding::vector) >= :threshold
   """)

   # Add discipline filter if provided
   if discipline:
       sql += " AND discipline = :discipline"

   sql += """
       ORDER BY embedding <=> :query_embedding::vector
       LIMIT :limit OFFSET :offset
   """

   params = {
       'query_embedding': query_embedding,
       'project_id': project_id,
       'threshold': similarity_threshold,
       'limit': limit,
       'offset': offset
   }

   if discipline:
       params['discipline'] = discipline

   results = db.execute(sql, params).fetchall()
   ```

3. **Format results**
   ```python
   decisions = []
   for row in results:
       decisions.append({
           'id': str(row.id),
           'statement': row.decision_statement,
           'who': row.who,
           'timestamp': row.timestamp,
           'discipline': row.discipline,
           'why': row.why,
           'similarity_score': round(row.similarity_score, 3),
           'created_at': row.created_at.isoformat()
       })

   return {
       'query': q,
       'results': decisions,
       'total': len(decisions),
       'limit': limit,
       'offset': offset
   }
   ```

### Task 3: Add Performance Optimization (0.5 days)

1. **Add query caching (optional)**
   ```python
   from functools import lru_cache
   from hashlib import md5

   @lru_cache(maxsize=100)
   def get_cached_query_embedding(query: str) -> List[float]:
       """Cache embeddings for popular queries."""
       return embedder.embed_text(query)
   ```

2. **Monitor query performance**
   ```python
   import time

   start = time.time()
   results = execute_vector_search(...)
   duration = time.time() - start

   logger.info(f"Semantic search for '{q}' took {duration*1000:.0f}ms")
   ```

3. **Add query timeout**
   - Set statement timeout to 5 seconds
   - Return 504 if query too slow

### Task 4: Handle Edge Cases (0.25 days)

1. **Empty results**
   ```python
   if not results:
       return {
           'query': q,
           'results': [],
           'total': 0,
           'limit': limit,
           'offset': offset,
           'message': 'No similar decisions found. Try lowering similarity_threshold.'
       }
   ```

2. **Query too short**
   - Return 400 if query < 3 characters
   - Provide helpful error message

3. **No embeddings exist**
   - Check if any decisions have embeddings
   - Return helpful message if none

4. **Invalid discipline filter**
   - Validate discipline against allowed values
   - Return 400 if invalid

### Task 5: Write Tests (0.5 days)

1. **Create test file: `tests/unit/test_semantic_search.py`**
   ```python
   @pytest.mark.asyncio
   async def test_semantic_search_endpoint():
       """Test semantic search returns similar decisions."""
       # Insert test decisions with embeddings
       d1 = create_decision(statement='Changed foundation depth')
       d2 = create_decision(statement='Modified foundation design')
       d3 = create_decision(statement='Updated MEP systems')

       response = await client.get(
           f'/api/projects/{project_id}/decisions/search?q=foundation changes'
       )

       assert response.status_code == 200
       results = response.json()['results']
       assert len(results) >= 2
       # d1 and d2 should be more similar than d3
       assert results[0]['statement'] in ['Changed foundation depth', 'Modified foundation design']

   @pytest.mark.asyncio
   async def test_similarity_threshold_filtering():
       """Test similarity threshold filters results."""
       response = await client.get(
           f'/api/projects/{project_id}/decisions/search',
           params={'q': 'foundation', 'similarity_threshold': 0.9}
       )

       results = response.json()['results']
       assert all(r['similarity_score'] >= 0.9 for r in results)

   @pytest.mark.asyncio
   async def test_discipline_filter_works():
       """Test discipline filtering with semantic search."""
       response = await client.get(
           f'/api/projects/{project_id}/decisions/search',
           params={'q': 'structural changes', 'discipline': 'structural'}
       )

       results = response.json()['results']
       assert all(r['discipline'] == 'structural' for r in results)
   ```

2. **Run tests**
   - `pytest tests/unit/test_semantic_search.py --cov`
   - Target: 80%+ coverage
   - All tests passing

---

## Dev Notes

### API Contract

**Endpoint:** `GET /api/projects/{project_id}/decisions/search`

**Request:**
```http
GET /api/projects/550e8400-e29b-41d4-a716-446655440001/decisions/search?q=foundation+changes&similarity_threshold=0.7&discipline=structural&limit=10&offset=0
Authorization: Bearer <token>
```

**Response:** 200 OK
```json
{
  "query": "foundation changes",
  "results": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440200",
      "statement": "Changed foundation depth from 2m to 3m",
      "who": "Carlos (Structural Engineer)",
      "timestamp": "00:23:15",
      "discipline": "structural",
      "why": "Soil analysis showed need for deeper foundations",
      "similarity_score": 0.87,
      "created_at": "2026-02-01T14:45:00Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440201",
      "statement": "Modified foundation reinforcement design",
      "who": "Carlos (Structural Engineer)",
      "timestamp": "00:45:12",
      "discipline": "structural",
      "why": "Updated based on new load calculations",
      "similarity_score": 0.82,
      "created_at": "2026-02-03T10:15:00Z"
    }
  ],
  "total": 2,
  "limit": 10,
  "offset": 0,
  "metadata": {
    "similarity_threshold": 0.7,
    "discipline_filter": "structural"
  }
}
```

**Error:** 400 Bad Request
```json
{
  "error": "validation_error",
  "detail": "Query must be at least 3 characters"
}
```

**Error:** 404 Not Found
```json
{
  "error": "resource_not_found",
  "detail": "Project with id 'xxx' not found"
}
```

**Error:** 403 Forbidden
```json
{
  "error": "permission_denied",
  "detail": "User does not have access to this project"
}
```

### Implementation Code

```python
# app/api/decisions.py
from fastapi import APIRouter, Query, Depends, HTTPException
from sqlalchemy import text
from typing import Optional, List
import time
import logging
from app.utils.embeddings import EmbeddingService
from app.database import Session
from app.api.deps import get_current_user, check_project_access

router = APIRouter()
embedder = EmbeddingService()
logger = logging.getLogger(__name__)

@router.get("/projects/{project_id}/decisions/search")
async def search_decisions(
    project_id: str,
    q: str = Query(..., min_length=3, description="Semantic search query"),
    similarity_threshold: float = Query(0.7, ge=0.0, le=1.0),
    discipline: Optional[str] = Query(None),
    limit: int = Query(10, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Semantic search for decisions using vector similarity.

    Finds decisions similar in meaning to the query, not just keyword matches.
    Returns results ordered by similarity score (0.0-1.0, higher is more similar).
    """

    # Check project access
    await check_project_access(project_id, current_user, db)

    # Validate discipline filter
    if discipline:
        valid_disciplines = ['architecture', 'mep', 'landscape', 'interior',
                           'electrical', 'plumbing', 'structural', 'general']
        if discipline not in valid_disciplines:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid discipline. Must be one of: {', '.join(valid_disciplines)}"
            )

    # Generate query embedding
    start = time.time()
    try:
        query_embedding = embedder.embed_text(q)
    except Exception as e:
        logger.error(f"Failed to embed query '{q}': {e}")
        raise HTTPException(status_code=500, detail="Failed to process search query")

    # Build SQL query
    sql = """
        SELECT
            id,
            decision_statement,
            who,
            timestamp,
            discipline,
            why,
            causation,
            impacts,
            consensus,
            confidence,
            created_at,
            1 - (embedding <=> :query_embedding::vector) as similarity_score
        FROM decisions
        WHERE project_id = :project_id
            AND embedding IS NOT NULL
            AND 1 - (embedding <=> :query_embedding::vector) >= :threshold
    """

    params = {
        'query_embedding': query_embedding,
        'project_id': project_id,
        'threshold': similarity_threshold
    }

    # Add optional discipline filter
    if discipline:
        sql += " AND discipline = :discipline"
        params['discipline'] = discipline

    # Add ordering and pagination
    sql += """
        ORDER BY embedding <=> :query_embedding::vector
        LIMIT :limit OFFSET :offset
    """
    params['limit'] = limit
    params['offset'] = offset

    # Execute query
    try:
        results = db.execute(text(sql), params).fetchall()
    except Exception as e:
        logger.error(f"Vector search query failed: {e}")
        raise HTTPException(status_code=500, detail="Search query failed")

    duration = time.time() - start
    logger.info(f"Semantic search '{q}' took {duration*1000:.0f}ms, found {len(results)} results")

    # Format results
    decisions = []
    for row in results:
        decisions.append({
            'id': str(row.id),
            'statement': row.decision_statement,
            'who': row.who,
            'timestamp': row.timestamp,
            'discipline': row.discipline,
            'why': row.why,
            'causation': row.causation,
            'impacts': row.impacts,
            'consensus': row.consensus,
            'confidence': row.confidence,
            'similarity_score': round(row.similarity_score, 3),
            'created_at': row.created_at.isoformat()
        })

    return {
        'query': q,
        'results': decisions,
        'total': len(decisions),
        'limit': limit,
        'offset': offset,
        'metadata': {
            'similarity_threshold': similarity_threshold,
            'discipline_filter': discipline,
            'query_time_ms': round(duration * 1000)
        }
    }
```

### Performance Benchmarks

| Decisions | No Index | With IVFFLAT | Target |
|-----------|----------|--------------|--------|
| 100 | <100ms | <50ms | <200ms |
| 1,000 | ~300ms | <150ms | <500ms |
| 10,000 | ~3s | <500ms | <1s |

### Vector Similarity Operators

```sql
-- Cosine distance (1 - cosine similarity)
embedding <=> query_vector

-- Convert to similarity score (0=different, 1=identical)
1 - (embedding <=> query_vector)

-- Filter by minimum similarity
WHERE 1 - (embedding <=> query_vector) >= 0.7

-- Sort by similarity (ascending distance = descending similarity)
ORDER BY embedding <=> query_vector
```

---

## File List

**Modified/Created:**
- `app/api/decisions.py` (modify) - Add semantic search endpoint
- `app/api/deps.py` (existing) - Use existing auth dependencies
- `tests/unit/test_semantic_search.py` (new) - Semantic search tests
- `tests/integration/test_search_api.py` (new) - End-to-end search tests

---

## Testing Strategy

### Unit Tests (`tests/unit/test_semantic_search.py`)

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.database.models import Decision, Project, User

client = TestClient(app)

@pytest.fixture
async def test_project_with_decisions(test_db):
    """Create test project with sample decisions."""
    project = Project(name='Test Project')
    test_db.add(project)
    test_db.commit()

    # Add decisions with known embeddings
    decisions = [
        Decision(
            project_id=project.id,
            statement='Changed foundation depth from 2m to 3m',
            who='Carlos',
            timestamp='00:23:15',
            discipline='structural',
            why='Soil analysis showed deeper foundations needed',
            embedding=[0.1] * 384  # Simplified for testing
        ),
        Decision(
            project_id=project.id,
            statement='Updated HVAC system design',
            who='Maria',
            timestamp='01:15:30',
            discipline='mep',
            why='Client requested more efficient system',
            embedding=[0.9] * 384  # Very different embedding
        )
    ]
    test_db.add_all(decisions)
    test_db.commit()

    return project

@pytest.mark.asyncio
async def test_semantic_search_returns_results(test_project_with_decisions, auth_headers):
    """Test semantic search endpoint returns similar decisions."""
    response = client.get(
        f'/api/projects/{test_project_with_decisions.id}/decisions/search',
        params={'q': 'foundation changes'},
        headers=auth_headers
    )

    assert response.status_code == 200
    data = response.json()
    assert 'results' in data
    assert 'query' in data
    assert data['query'] == 'foundation changes'

@pytest.mark.asyncio
async def test_similarity_threshold_works(test_project_with_decisions, auth_headers):
    """Test similarity threshold filters low-scoring results."""
    response = client.get(
        f'/api/projects/{test_project_with_decisions.id}/decisions/search',
        params={'q': 'foundation', 'similarity_threshold': 0.95},
        headers=auth_headers
    )

    assert response.status_code == 200
    results = response.json()['results']

    # All results should have high similarity
    for r in results:
        assert r['similarity_score'] >= 0.95

@pytest.mark.asyncio
async def test_pagination_works(test_project_with_decisions, auth_headers):
    """Test pagination parameters work correctly."""
    response = client.get(
        f'/api/projects/{test_project_with_decisions.id}/decisions/search',
        params={'q': 'changes', 'limit': 1, 'offset': 0},
        headers=auth_headers
    )

    assert response.status_code == 200
    data = response.json()
    assert data['limit'] == 1
    assert len(data['results']) <= 1

@pytest.mark.asyncio
async def test_query_too_short_returns_error(test_project_with_decisions, auth_headers):
    """Test query must be at least 3 characters."""
    response = client.get(
        f'/api/projects/{test_project_with_decisions.id}/decisions/search',
        params={'q': 'ab'},  # Only 2 chars
        headers=auth_headers
    )

    assert response.status_code == 422  # Validation error

@pytest.mark.asyncio
async def test_unauthorized_user_denied(test_project_with_decisions):
    """Test unauthorized user cannot search project."""
    response = client.get(
        f'/api/projects/{test_project_with_decisions.id}/decisions/search',
        params={'q': 'foundation'}
        # No auth headers
    )

    assert response.status_code == 401
```

### Integration Test

```python
@pytest.mark.integration
@pytest.mark.asyncio
async def test_semantic_search_end_to_end(test_db):
    """Test full semantic search flow with real embeddings."""
    from app.utils.embeddings import EmbeddingService

    embedder = EmbeddingService()

    # Create project and decisions
    project = Project(name='Integration Test Project')
    test_db.add(project)
    test_db.commit()

    decisions_data = [
        ('Changed foundation depth', 'Deeper foundations needed'),
        ('Modified foundation design', 'Updated structural calculations'),
        ('Updated HVAC system', 'Client requested efficiency improvements')
    ]

    for statement, why in decisions_data:
        embedding = embedder.embed_text(f'{statement} {why}')
        decision = Decision(
            project_id=project.id,
            statement=statement,
            why=why,
            who='Test User',
            timestamp='00:00:00',
            discipline='structural',
            embedding=embedding
        )
        test_db.add(decision)

    test_db.commit()

    # Perform search
    response = client.get(
        f'/api/projects/{project.id}/decisions/search',
        params={'q': 'foundation changes'},
        headers=get_auth_headers(test_db)
    )

    assert response.status_code == 200
    results = response.json()['results']

    # Verify foundation decisions ranked higher than HVAC
    assert len(results) >= 2
    assert 'foundation' in results[0]['statement'].lower()
    assert results[0]['similarity_score'] > 0.7
```

---

## Change Log

| Date | Change |
|------|--------|
| 2026-02-08 | Created story |

---

**Related Stories:** 2.1 (Embeddings), 2.2 (pgvector), 2.3 (Pipeline)
**Blocked By:** 2.3 (needs decisions with embeddings in DB)
**Blocks:** 3.6 (frontend search needs this API)
