# Story 3.9: API Endpoints - Timeline & Digest

**Story ID:** 3.9
**Assigned to:** @dev
**Sprint:** Sprint 5 (Week 7)
**Status:** Draft
**Estimation:** 8 story points (3-4 days)

---

## Summary

Implement backend API endpoints for timeline and digest views: decision listing with filters, decision detail with context, and project digest with categorized summaries. Includes pagination, performance optimization, and comprehensive error handling.

---

## UX Research Context

This story provides **critical data infrastructure** enabling all frontend stories (3.4-3.8). While backend-focused, it directly impacts user experience through:

**Performance = User Experience**
- **Timeline load <2 seconds** (UX Insight 4 - Gabriela on mobile/iPad needs fast access)
- Decision list filtering <200ms (users expect instant results)
- Digest generation <500ms (executives expect quick summaries)
- **Bad performance = Users abandon app** (especially on mobile with slow connections)

**Accurate Data = User Trust**
- Decisions must return complete data (transcript, similar decisions, consensus, impacts)
- Missing data = Frontend components break (blank modals, lost trust)
- Consistency validation ensures data integrity (similar decisions, past decision precedents)

**Proper Filtering = Enable UX Insights**
- **Insight 3 (Discipline-First):** Filter endpoint must support discipline + date + meeting_type simultaneously
- **Insight 2 (Digest vs. Deep Dive):** Timeline view needs all decisions, Digest needs categorized summaries
- **Insight 1 (Trust Through Transparency):** Detail endpoint provides full context (transcript, similar, consistency)

**Mobile Data Efficiency**
- Pagination critical for mobile (don't load 200 decisions at once)
- Facets (discipline counts, meeting type counts) help UI show filter options efficiently
- Limit defaults sensible (50 decisions per page)

**Reference:** All frontend stories (3.4, 3.5, 3.6, 3.7, 3.8) depend on these API endpoints

---

## Acceptance Criteria

### Decision List Endpoint (UX Insight 3: Discipline-First Filtering)
- [ ] Endpoint: `GET /api/projects/{id}/decisions` (Timeline data source)
- [ ] Query parameters:
  - [ ] `discipline` (optional): Comma-separated list (architecture,mep,landscape,etc.)
  - [ ] `meeting_type` (optional): Comma-separated (client,multi-disc,internal)
  - [ ] `date_from` (optional): ISO 8601 date (2026-01-01)
  - [ ] `date_to` (optional): ISO 8601 date
  - [ ] `search` (optional): Full-text search (decision statement + why fields)
  - [ ] `limit` (optional, default 50): Pagination size
  - [ ] `offset` (optional, default 0): Pagination offset
- [ ] Response structure:
  ```json
  {
    "decisions": [...],     // List of DecisionResponse
    "total": 200,           // Total matching decisions
    "limit": 50,            // Current page size
    "offset": 0,            // Current page offset
    "facets": {             // For filter UI (counts)
      "disciplines": {      // Show discipline options + counts
        "Architecture": 45,
        "MEP": 38,
        "Landscape": 22,
        ...
      },
      "meeting_types": {
        "Client": 40,
        "Multi-disciplinary": 60,
        "Internal": 30
      }
    }
  }
  ```
- [ ] Filtering logic (AND of all filters):
  - Discipline: If specified, only return decisions where discipline IN [list]
  - Meeting type: If specified, only return decisions where meeting_type IN [list]
  - Date range: If specified, only return decisions WHERE created_at >= date_from AND <= date_to
  - Search: If specified, full-text search on decision_statement + why (case-insensitive)
- [ ] Sorting: Order by created_at DESC (newest first)
- [ ] Authorization: Check project access (user must be member of project)
- [ ] Performance: <200ms per request (even with 200+ decisions)
  - Use database indexes on (project_id, discipline, meeting_type, created_at)
  - Use ILIKE with indexes for search
- [ ] Error handling:
  - 403 Forbidden: User doesn't have access to project
  - 404 Not Found: Project doesn't exist
  - 400 Bad Request: Invalid date format, invalid discipline value, etc.

### Decision Detail Endpoint (UX Insight 1: Trust Through Transparency)
- [ ] Endpoint: `GET /api/decisions/{id}` (Drill-Down Modal data source)
- [ ] Response structure:
  ```json
  {
    "id": "uuid",
    "decision_statement": "...",
    "who": "speaker name",
    "timestamp": "HH:MM:SS",
    "discipline": "Architecture",
    "meeting_type": "client",
    "meeting_date": "2026-02-01T14:00:00Z",
    "why": "Full reasoning text (2-3 sentences)",
    "causation": "What triggered this decision",
    "impacts": [
      { "type": "timeline", "change": "+2 weeks" },
      { "type": "budget", "change": "+$15k" }
    ],
    "consensus": {
      "Architecture": "AGREE",
      "MEP": "MIXED",
      "Structural": "AGREE"
    },
    "confidence": 0.92,
    "confidence_breakdown": {
      "consensus": 0.95,
      "consistency": 0.87,
      "historical": 0.94
    },
    "consistency_score": 0.87,
    "consistency_notes": "Aligns with Decision #3 (sustainable materials policy)",
    "anomaly_flags": [
      { "type": "high_dissent", "severity": "medium", "description": "..." }
    ],
    "transcript_excerpt": "Speaker: text...\n[DECISION MOMENT]\nSpeaker: text...",
    "similar_decisions": [
      { "id": "uuid", "statement": "...", "similarity_score": 0.94 }
    ]
  }
  ```
- [ ] Data requirements:
  - Full decision statement, who, when, why (reasoning)
  - Causation: What triggered this decision
  - Impacts: All timeline/scope/budget changes
  - Consensus: Per-discipline breakdown (AGREE/MIXED/DISSENT)
  - Confidence: Overall + breakdown (consensus + consistency + historical)
  - Consistency: Score + notes about alignment with past decisions
  - Anomaly flags: Any warnings (high dissent, unusual pattern, etc.)
  - Transcript excerpt: 5-10 minute context with speaker prefixes, decision moment highlighted
  - Similar decisions: Top 5 by similarity score (vector search), include statement + score
- [ ] Authorization: User must have access to project containing this decision
- [ ] Performance: <300ms per request
  - Vector search for similar decisions should be optimized (embeddings, index)
- [ ] Error handling:
  - 403 Forbidden: User doesn't have access
  - 404 Not Found: Decision doesn't exist

### Executive Digest Endpoint (UX Insight 2: Digest vs. Deep Dive)
- [ ] Endpoint: `GET /api/projects/{id}/digest?date_from=X&date_to=Y` (Digest data source)
- [ ] Required parameters:
  - `date_from` (required): ISO 8601 date
  - `date_to` (required): ISO 8601 date
- [ ] Response structure:
  ```json
  {
    "project": { "id": "uuid", "name": "Project Name" },
    "period": { "from": "2026-01-01", "to": "2026-01-07" },
    "stats": {
      "total_decisions": 42,
      "meetings_count": 8,
      "consensus_percentage": 0.85,
      "high_impact_count": 5
    },
    "highlights": {
      "structural_changes": [
        { "id": "uuid", "statement": "...", "impact_summary": "..." }
      ],
      "cost_impacts": [
        { "id": "uuid", "statement": "...", "impact_summary": "+$15k" }
      ],
      "timeline_shifts": [
        { "id": "uuid", "statement": "...", "impact_summary": "+2 weeks" }
      ],
      "risk_flags": [
        { "id": "uuid", "statement": "...", "anomaly_flags": [...] }
      ]
    },
    "generated_at": "2026-02-08T10:30:00Z"
  }
  ```
- [ ] Digest logic:
  - Stats: Count decisions in date range, calculate consensus %, count high-impact decisions
  - Highlights:
    - Structural: Decisions affecting structure/materials (categorize from statement analysis)
    - Cost: Decisions with budget impacts, sum total cost changes
    - Timeline: Decisions with schedule impacts, sum total timeline changes
    - Risk: Decisions with anomaly flags or high dissent (consensus < 60%)
  - Return top 3-5 decisions per category
- [ ] Authorization: User must have access to project
- [ ] Performance: <500ms per request (complex aggregation)
- [ ] Error handling:
  - 403 Forbidden: User doesn't have access
  - 404 Not Found: Project doesn't exist
  - 400 Bad Request: date_from/date_to not provided or invalid format

### Error Handling (Frontend Compatibility)
- [ ] All endpoints return standard error format:
  ```json
  { "status": 400, "detail": "User-friendly error message" }
  ```
- [ ] HTTP status codes:
  - 400 Bad Request: Invalid query parameters, missing required fields
  - 403 Forbidden: User doesn't have access
  - 404 Not Found: Resource doesn't exist
  - 500 Server Error: Unexpected error (log for debugging)
- [ ] Error messages for frontend (from Story 3.2):
  - "Invalid date format. Use YYYY-MM-DD"
  - "Access denied. You do not have permission to view this project"
  - "Project not found"
  - "Invalid filter value. Use: architecture, mep, landscape, etc."

### Testing
- [ ] Unit tests (>80% coverage):
  - Decision list endpoint: filters, pagination, facets, search
  - Decision detail endpoint: returns all required fields
  - Digest endpoint: stats calculation, highlights categorization
  - Error scenarios: 403, 404, 400
- [ ] Integration tests: End-to-end with database
- [ ] Performance tests:
  - Decision list: <200ms with 200+ decisions
  - Decision detail: <300ms including vector search
  - Digest: <500ms with complex aggregation

---

## Tasks

### Task 1: Decision List Endpoint (1.5 days)

```python
# app/api/endpoints/decisions.py

@app.get("/api/projects/{project_id}/decisions")
async def list_decisions(
    project_id: str,
    discipline: Optional[str] = None,
    meeting_type: Optional[str] = None,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    search: Optional[str] = None,
    limit: int = 50,
    offset: int = 0,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # Check project access
    if not has_project_access(current_user, project_id, db):
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Build query with filters
    query = db.query(Decision).filter(Decision.project_id == project_id)
    
    if discipline:
        query = query.filter(Decision.discipline.in_(discipline.split(',')))
    if meeting_type:
        query = query.filter(Decision.meeting_type.in_(meeting_type.split(',')))
    if date_from:
        query = query.filter(Decision.created_at >= date_from)
    if date_to:
        query = query.filter(Decision.created_at <= date_to)
    if search:
        query = query.filter(
            or_(
                Decision.decision_statement.ilike(f"%{search}%"),
                Decision.why.ilike(f"%{search}%")
            )
        )
    
    total = query.count()
    decisions = query.order_by(Decision.created_at.desc()).limit(limit).offset(offset).all()
    
    # Get facets
    facets = get_decision_facets(project_id, db)
    
    return {
        "decisions": [DecisionResponse.from_orm(d) for d in decisions],
        "total": total,
        "limit": limit,
        "offset": offset,
        "facets": facets
    }
```

### Task 2: Decision Detail Endpoint (1.5 days)

```python
@app.get("/api/decisions/{decision_id}")
async def get_decision_detail(
    decision_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    decision = db.query(Decision).filter(Decision.id == decision_id).first()
    if not decision:
        raise HTTPException(status_code=404, detail="Decision not found")
    
    # Check project access
    if not has_project_access(current_user, decision.project_id, db):
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Get transcript excerpt
    transcript_excerpt = get_transcript_excerpt(decision, db)
    
    # Get similar decisions (vector search)
    similar_decisions = find_similar_decisions(decision, db, limit=5)
    
    # Get meeting info
    meeting = db.query(Transcript).filter(
        Transcript.id == decision.transcript_id
    ).first()
    
    return {
        **DecisionResponse.from_orm(decision).dict(),
        "transcript_excerpt": transcript_excerpt,
        "similar_decisions": similar_decisions,
        "meeting": MeetingInfo.from_orm(meeting) if meeting else None,
    }
```

### Task 3: Digest Endpoint (1.5 days)

```python
@app.get("/api/projects/{project_id}/digest")
async def get_project_digest(
    project_id: str,
    date_from: date,
    date_to: date,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    if not has_project_access(current_user, project_id, db):
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Get decisions in date range
    decisions = db.query(Decision).filter(
        Decision.project_id == project_id,
        Decision.created_at >= date_from,
        Decision.created_at <= date_to
    ).all()
    
    # Calculate summary stats
    summary = {
        "total_decisions": len(decisions),
        "by_discipline": calculate_discipline_counts(decisions),
        "high_impact_decisions": len([d for d in decisions if has_high_impact(d)]),
        "decisions_with_dissent": len([d for d in decisions if has_dissent(d)]),
    }
    
    # Categorize highlights
    highlights = categorize_decisions(decisions)
    
    # Get anomalies
    anomalies = [
        {
            "decision_id": d.id,
            "flag": flag["type"],
            "severity": flag["severity"],
            "description": flag["description"]
        }
        for d in decisions
        for flag in (d.anomaly_flags or [])
    ]
    
    project = db.query(Project).filter(Project.id == project_id).first()
    
    return {
        "project": {"id": project.id, "name": project.name},
        "period": {"from": date_from, "to": date_to},
        "summary": summary,
        "highlights": highlights,
        "anomalies": anomalies
    }
```

### Task 4: Helper Functions (1 day)

Implement transcript excerpt extraction, vector similarity search, decision categorization, and facet calculation.

### Task 5: Write Tests (0.5 days)

```python
# tests/api/test_decisions.py

def test_list_decisions(client, test_user, test_project):
    response = client.get(
        f"/api/projects/{test_project.id}/decisions",
        headers={"Authorization": f"Bearer {test_user.token}"}
    )
    assert response.status_code == 200
    assert "decisions" in response.json()

def test_filter_by_discipline(client, test_user, test_project):
    response = client.get(
        f"/api/projects/{test_project.id}/decisions?discipline=architecture",
        headers={"Authorization": f"Bearer {test_user.token}"}
    )
    assert response.status_code == 200
    decisions = response.json()["decisions"]
    assert all(d["discipline"] == "architecture" for d in decisions)

def test_decision_detail(client, test_user, test_decision):
    response = client.get(
        f"/api/decisions/{test_decision.id}",
        headers={"Authorization": f"Bearer {test_user.token}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "transcript_excerpt" in data
    assert "similar_decisions" in data

def test_digest(client, test_user, test_project):
    response = client.get(
        f"/api/projects/{test_project.id}/digest?date_from=2026-01-01&date_to=2026-02-01",
        headers={"Authorization": f"Bearer {test_user.token}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "summary" in data
    assert "highlights" in data
```

---

## Dev Notes

### Performance Optimization

- Use database indexes for filter queries
- Limit vector search to project scope
- Cache facet calculations (Redis optional)
- Paginate large result sets

### Vector Search

```python
def find_similar_decisions(decision, db, limit=5):
    # Use pgvector cosine similarity
    results = db.query(Decision).filter(
        Decision.project_id == decision.project_id,
        Decision.id != decision.id
    ).order_by(
        Decision.embedding.cosine_distance(decision.embedding)
    ).limit(limit).all()
    
    return [
        {
            "decision_id": d.id,
            "similarity_score": 1 - decision.embedding.cosine_distance(d.embedding),
            "decision_statement": d.decision_statement
        }
        for d in results
    ]
```

---

## File List

**Modified/Created:**
- `app/api/endpoints/decisions.py` (new)
- `app/api/endpoints/digest.py` (new)
- `app/services/decision_service.py` (new)
- `app/services/digest_service.py` (new)
- `tests/api/test_decisions.py` (new)
- `tests/api/test_digest.py` (new)

---

## Testing Strategy

- ✅ List decisions with filters
- ✅ Pagination
- ✅ Search functionality
- ✅ Decision detail with transcript
- ✅ Similar decisions vector search
- ✅ Digest generation
- ✅ Date range filtering
- ✅ Access control (403)
- ✅ Performance (<200ms, <500ms)

---

## Change Log

| Date | Change |
|------|--------|
| 2026-02-08 | Added UX Research Context, comprehensive acceptance criteria with all endpoint specifications, and integration notes linking to frontend dependencies |
| 2026-02-08 | Created story |

---

**Related Stories:** 3.2 (API Service Layer), 3.3 (Authentication), 3.5 (Timeline), 3.6 (Filters), 3.7 (Drill-down), 3.8 (Digest)
**Blocked By:** 3.2, 3.3 (for token validation patterns)
**Blocks:** 3.5, 3.6, 3.7, 3.8 (frontend stories depend on these endpoints)
