# Story 3.2: API Service Layer

**Story ID:** 3.2
**Assigned to:** @dev
**Sprint:** Sprint 4 (Week 6)
**Status:** Draft
**Estimation:** 3 story points (1-2 days)

---

## Summary

Create a centralized API service layer for all backend HTTP requests with TypeScript type safety, JWT token management, error handling, and request/response interceptors. This provides a consistent interface for all frontend-backend communication.

---

## UX Research Context

This story provides **critical infrastructure** enabling all frontend features from Priority A & B. While not directly user-facing, it impacts user experience through:

**Reliable Data Access (Enables All UX Insights)**
- All frontend stories (Timeline, Filters, Digest, Drill-down) depend on reliable API calls
- **Bad API layer = Data loading errors, retry issues, user frustration**
- **Good API layer = Smooth data flow, consistent user experience**

**Error Handling for User Experience**
- API errors must be translated to **user-friendly messages**
- Examples (from error handling task):
  - **401 Unauthorized:** "Authentication required. Please log in." → Redirect to login (not "401 Error")
  - **404 Not Found:** "Resource not found." → User understands data doesn't exist
  - **Network Error:** "Network error. Please check your internet connection." → User understands to check WiFi/mobile signal
- **Bad error handling = Cryptic "Error 500" messages, lost trust**
- **Good error handling = Clear messages, user confidence**

**Type Safety (Prevents Frontend Bugs)**
- TypeScript interfaces ensure frontend receives correct data structure
- Example: `DecisionDetailResponse` has `similarity_decisions`, `transcript_excerpt`, `anomaly_flags`
- If backend changes response, TypeScript catches it at compile time (not at runtime when user sees blank data)

**Performance (Supports Responsive Design)**
- React Query integration (in other stories) needs reliable API client
- Timeout handling (30 seconds) prevents hanging requests on slow connections
- Important for Gabriela on mobile/tablet with variable connectivity

**Security (Protects User Data)**
- JWT token management via HTTP-only cookies (secure)
- Auto-logout on 401 (compromised token)
- Prevents token leaks in browser console

**Reference:** All frontend stories (3.4, 3.5, 3.6, 3.7, 3.8, 3.9) depend on this service layer

---

## Acceptance Criteria

### API Client Implementation
- [ ] API client class (`src/services/api.ts`) implemented with TypeScript
- [ ] Axios HTTP client configured:
  - [ ] Base URL from environment variable `VITE_API_URL`
  - [ ] Default timeout: 30 seconds
  - [ ] `withCredentials: true` (send HTTP-only cookies)
  - [ ] Default headers: `Content-Type: application/json`
- [ ] HTTP methods exposed:
  - [ ] `get<T>(endpoint, config?)`: GET request
  - [ ] `post<T>(endpoint, data, config?)`: POST request
  - [ ] `patch<T>(endpoint, data, config?)`: PATCH request
  - [ ] `delete<T>(endpoint, config?)`: DELETE request
  - [ ] `request<T>(method, endpoint, data, config?)`: Generic request
- [ ] Generic method signature: `async get<T>` returns `Promise<T>` (TypeScript generic)
- [ ] Singleton instance: `export const api = new ApiClient()`

### JWT Token Management (Security)
- [ ] Token handling via HTTP-only cookies (primary):
  - [ ] Reads `access_token` cookie automatically (axios `withCredentials: true`)
  - [ ] Token sent in all requests without manual intervention
  - [ ] HTTP-only prevents JavaScript access (secure)
- [ ] Authorization header fallback:
  - [ ] If token not in cookie, check `Authorization: Bearer {token}` header
  - [ ] Allows testing, mobile WebView compatibility
- [ ] Request interceptor adds token if needed:
  - [ ] Extracts token from cookie: `getTokenFromCookie()`
  - [ ] Sets `Authorization: Bearer {token}` if not already present
- [ ] No token refresh (defer to Phase 2 if needed)

### Error Handling (UX-Friendly Messages)
- [ ] Custom `ApiError` class extending Error:
  - [ ] Properties: `status: number`, `message: string`, `data?: any`
  - [ ] Constructor takes all three properties
- [ ] Error messages (user-friendly, not cryptic codes):
  - [ ] **401 Unauthorized:** "Authentication required. Please log in." → Auto-logout + redirect to /login
  - [ ] **403 Forbidden:** "Access denied. You do not have permission to view this resource."
  - [ ] **404 Not Found:** "Resource not found."
  - [ ] **429 Too Many Requests:** "Too many requests. Please try again later."
  - [ ] **500 Server Error:** "Server error. Please try again."
  - [ ] **0 Network Error:** "Network error. Please check your internet connection."
  - [ ] **Other:** Use server response message or "An unexpected error occurred."
- [ ] Error handling strategy:
  - **Response error (server returned error):** Extract status, message, data
  - **Request error (no response):** Network error (status 0), friendly message
  - **Other error:** Generic message
- [ ] Response interceptor (error handling):
  - [ ] On 401: Call `useAuthStore.getState().logout()` + redirect to `/login`
  - [ ] On other errors: Throw `ApiError` with details
  - [ ] Allows components to catch and display error message

### TypeScript Types (Type Safety for Frontend)
- [ ] Request/response types in `src/types/api.ts`:
  - [ ] **Auth:** `LoginRequest`, `LoginResponse`
  - [ ] **Projects:** `ProjectsResponse`, `ProjectDetailResponse`, `ProjectMember`, `ProjectStats`
  - [ ] **Decisions:** `DecisionsResponse`, `DecisionDetailResponse`, `SimilarDecision`, `TranscriptExcerpt`, `MeetingInfo`
  - [ ] **Digest:** `DigestResponse`, `DigestSummary`, `DigestHighlight`, `DigestAnomaly`
  - [ ] **Filters:** `DecisionFilters` with optional fields
- [ ] All types extend from base types (`User`, `Project`, `Decision` from `src/types/index.ts`)
- [ ] Response types include data from all frontend components:
  - [ ] `DecisionDetailResponse` has `similar_decisions`, `consistency_notes`, `transcript_excerpt`, `meeting` (for drill-down modal)
  - [ ] `DecisionsResponse` has `facets` with discipline/meeting_type counts (for filters)
  - [ ] `DigestResponse` has stats + highlights (for digest page)

### API Service Methods
- [ ] Auth endpoints:
  - [ ] `login(credentials: LoginRequest): Promise<LoginResponse>`
  - [ ] `logout(): Promise<void>`
  - [ ] `getCurrentUser(): Promise<User>`
- [ ] Project endpoints:
  - [ ] `getProjects(limit?, offset?): Promise<ProjectsResponse>`
  - [ ] `getProject(projectId): Promise<ProjectDetailResponse>`
- [ ] Decision endpoints:
  - [ ] `getDecisions(projectId, filters?): Promise<DecisionsResponse>`
    - Supports filter query params: discipline, meeting_type, date_from, date_to, search, limit, offset
  - [ ] `getDecision(decisionId): Promise<DecisionDetailResponse>`
- [ ] Digest endpoint:
  - [ ] `getDigest(projectId, fromDate, toDate): Promise<DigestResponse>`
- [ ] URL construction:
  - [ ] Use URLSearchParams for query parameters
  - [ ] Properly encode special characters
  - [ ] Example: `/projects/{projectId}/decisions?discipline=mep,architecture&date_from=2026-01-01`

### Configuration & Environment
- [ ] Base URL configurable:
  - [ ] Read from `import.meta.env.VITE_API_URL` (Vite environment variable)
  - [ ] Fallback default: `http://localhost:8000/api` (development)
- [ ] Environment files (`.env`, `.env.production`):
  - [ ] Development: `VITE_API_URL=http://localhost:8000/api`
  - [ ] Production: `VITE_API_URL=https://api.decisionlog.io/api`
- [ ] No hardcoded API URLs in code

### Request/Response Interceptors
- [ ] Request interceptor:
  - [ ] Automatically adds JWT token from cookie (via `getTokenFromCookie()`)
  - [ ] Adds token to `Authorization: Bearer {token}` header if needed
  - [ ] Ensures all requests include authentication
- [ ] Response interceptor:
  - [ ] On success: Return response data
  - [ ] On 401 error: Auto-logout user + redirect to `/login`
  - [ ] On other errors: Throw `ApiError` with status and message

### Timeout Handling
- [ ] Default timeout: 30 seconds (30000 milliseconds)
- [ ] Prevents hanging requests on slow connections
- [ ] Allows override per request via `config?.timeout`
- [ ] Critical for mobile users (Gabriela on iPad with variable connectivity)

### Testing
- [ ] Unit tests >80% coverage:
  - [ ] API client initialization (correct base URL, timeout, credentials)
  - [ ] GET/POST/PATCH/DELETE methods work correctly
  - [ ] Error handling (401, 403, 404, 500, network errors)
  - [ ] Token extraction from cookie
  - [ ] Request/response interceptors registered
  - [ ] Generic type safety (TypeScript compilation)
- [ ] Manual testing:
  - [ ] Login with valid/invalid credentials
  - [ ] Fetch projects, decisions, digest
  - [ ] Test error scenarios (disconnect network, invalid token)
  - [ ] Verify timeout works (slow network simulation)

---

## Tasks

### Task 1: Create API Client Class (0.5 days)

1. **Create `src/services/api.ts`**
   ```typescript
   import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'
   import { useAuthStore } from '../store/authStore'

   class ApiClient {
     private client: AxiosInstance
     private baseUrl: string

     constructor() {
       this.baseUrl = import.meta.env.VITE_API_URL || 'http://localhost:8000/api'

       this.client = axios.create({
         baseURL: this.baseUrl,
         timeout: 30000, // 30 seconds
         withCredentials: true, // Send cookies
         headers: {
           'Content-Type': 'application/json',
         },
       })

       this.setupInterceptors()
     }

     private setupInterceptors() {
       // Request interceptor
       this.client.interceptors.request.use(
         (config) => {
           // Token automatically sent via cookie
           // But support Authorization header as fallback
           const token = this.getTokenFromCookie()
           if (token && !config.headers.Authorization) {
             config.headers.Authorization = `Bearer ${token}`
           }
           return config
         },
         (error) => Promise.reject(error)
       )

       // Response interceptor
       this.client.interceptors.response.use(
         (response) => response,
         (error) => {
           if (error.response?.status === 401) {
             // Unauthorized - logout and redirect
             useAuthStore.getState().logout()
             window.location.href = '/login'
           }
           return Promise.reject(error)
         }
       )
     }

     private getTokenFromCookie(): string | null {
       const cookies = document.cookie.split(';')
       const tokenCookie = cookies.find(c => c.trim().startsWith('access_token='))
       return tokenCookie ? tokenCookie.split('=')[1] : null
     }

     async request<T>(
       method: string,
       endpoint: string,
       data?: unknown,
       config?: AxiosRequestConfig
     ): Promise<T> {
       try {
         const response: AxiosResponse<T> = await this.client.request({
           method,
           url: endpoint,
           data,
           ...config,
         })
         return response.data
       } catch (error: any) {
         throw this.handleError(error)
       }
     }

     private handleError(error: any): ApiError {
       if (error.response) {
         // Server responded with error status
         return new ApiError(
           error.response.status,
           error.response.data?.detail || error.response.statusText,
           error.response.data
         )
       } else if (error.request) {
         // Request made but no response
         return new ApiError(0, 'Network error - please check your connection')
       } else {
         // Something else happened
         return new ApiError(0, error.message)
       }
     }

     // Convenience methods
     get<T>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
       return this.request<T>('GET', endpoint, undefined, config)
     }

     post<T>(endpoint: string, data?: unknown, config?: AxiosRequestConfig): Promise<T> {
       return this.request<T>('POST', endpoint, data, config)
     }

     patch<T>(endpoint: string, data?: unknown, config?: AxiosRequestConfig): Promise<T> {
       return this.request<T>('PATCH', endpoint, data, config)
     }

     delete<T>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
       return this.request<T>('DELETE', endpoint, undefined, config)
     }
   }

   export class ApiError extends Error {
     constructor(
       public status: number,
       public message: string,
       public data?: any
     ) {
       super(message)
       this.name = 'ApiError'
     }
   }

   // Export singleton instance
   export const api = new ApiClient()
   ```

2. **Test API client initialization**
   - Verify axios instance created
   - Check base URL from environment
   - Test interceptors registered

### Task 2: Define TypeScript Types (0.25 days)

1. **Create request/response types in `src/types/api.ts`**
   ```typescript
   import { User, Project, Decision } from './index'

   // Auth types
   export interface LoginRequest {
     email: string
     password: string
   }

   export interface LoginResponse {
     user: User
   }

   // Project types
   export interface ProjectsResponse {
     projects: Project[]
     total: number
     limit: number
     offset: number
   }

   export interface ProjectDetailResponse extends Project {
     members: ProjectMember[]
     stats: ProjectStats
   }

   export interface ProjectMember {
     user_id: string
     name: string
     email: string
     role: string
   }

   export interface ProjectStats {
     total_decisions: number
     decisions_last_week: number
     decisions_by_discipline: Record<string, number>
     decisions_by_meeting_type: Record<string, number>
   }

   // Decision types
   export interface DecisionsResponse {
     decisions: Decision[]
     total: number
     limit: number
     offset: number
     facets?: {
       disciplines: Record<string, number>
       meeting_types: Record<string, number>
     }
   }

   export interface DecisionDetailResponse extends Decision {
     similar_decisions?: SimilarDecision[]
     consistency_notes?: string
     transcript_excerpt?: TranscriptExcerpt
     meeting?: MeetingInfo
   }

   export interface SimilarDecision {
     decision_id: string
     similarity_score: number
     decision_statement: string
   }

   export interface TranscriptExcerpt {
     text: string
     start: string
     end: string
   }

   export interface MeetingInfo {
     id: string
     type: string
     date: string
     duration_minutes: number
     participants: Participant[]
   }

   export interface Participant {
     name: string
     email: string
     role: string
   }

   // Digest types
   export interface DigestResponse {
     project: {
       id: string
       name: string
     }
     period: {
       from: string
       to: string
     }
     summary: DigestSummary
     highlights: DigestHighlight[]
     anomalies: DigestAnomaly[]
   }

   export interface DigestSummary {
     total_decisions: number
     by_discipline: Record<string, number>
     high_impact_decisions: number
     decisions_with_dissent: number
   }

   export interface DigestHighlight {
     type: string
     count: number
     title: string
     description: string
     decision_ids: string[]
   }

   export interface DigestAnomaly {
     decision_id: string
     flag: string
     severity: 'low' | 'medium' | 'high'
     description: string
   }

   // Filter types
   export interface DecisionFilters {
     discipline?: string[]
     meeting_type?: string[]
     date_from?: string
     date_to?: string
     confidence_min?: number
     has_anomalies?: boolean
     search?: string
     limit?: number
     offset?: number
   }
   ```

### Task 3: Create API Service Methods (0.5 days)

1. **Add service methods to `src/services/api.ts`**
   ```typescript
   import {
     LoginRequest,
     LoginResponse,
     ProjectsResponse,
     ProjectDetailResponse,
     DecisionsResponse,
     DecisionDetailResponse,
     DigestResponse,
     DecisionFilters
   } from '../types/api'

   class ApiClient {
     // ... existing code ...

     // Auth endpoints
     async login(credentials: LoginRequest): Promise<LoginResponse> {
       return this.post<LoginResponse>('/auth/login', credentials)
     }

     async logout(): Promise<void> {
       return this.post<void>('/auth/logout')
     }

     async getCurrentUser(): Promise<User> {
       return this.get<User>('/auth/me')
     }

     // Project endpoints
     async getProjects(limit = 50, offset = 0): Promise<ProjectsResponse> {
       return this.get<ProjectsResponse>(`/projects?limit=${limit}&offset=${offset}`)
     }

     async getProject(projectId: string): Promise<ProjectDetailResponse> {
       return this.get<ProjectDetailResponse>(`/projects/${projectId}`)
     }

     // Decision endpoints
     async getDecisions(
       projectId: string,
       filters?: DecisionFilters
     ): Promise<DecisionsResponse> {
       const params = new URLSearchParams()
       if (filters?.discipline?.length) {
         params.append('discipline', filters.discipline.join(','))
       }
       if (filters?.meeting_type?.length) {
         params.append('meeting_type', filters.meeting_type.join(','))
       }
       if (filters?.date_from) params.append('date_from', filters.date_from)
       if (filters?.date_to) params.append('date_to', filters.date_to)
       if (filters?.search) params.append('search', filters.search)
       if (filters?.limit) params.append('limit', filters.limit.toString())
       if (filters?.offset) params.append('offset', filters.offset.toString())

       const query = params.toString()
       const url = `/projects/${projectId}/decisions${query ? `?${query}` : ''}`
       return this.get<DecisionsResponse>(url)
     }

     async getDecision(decisionId: string): Promise<DecisionDetailResponse> {
       return this.get<DecisionDetailResponse>(`/decisions/${decisionId}`)
     }

     // Digest endpoint
     async getDigest(
       projectId: string,
       fromDate: string,
       toDate: string
     ): Promise<DigestResponse> {
       return this.get<DigestResponse>(
         `/projects/${projectId}/digest?date_from=${fromDate}&date_to=${toDate}`
       )
     }
   }
   ```

### Task 4: Error Handling and User Feedback (0.25 days)

1. **Create error utility in `src/lib/errors.ts`**
   ```typescript
   import { ApiError } from '../services/api'

   export function getErrorMessage(error: unknown): string {
     if (error instanceof ApiError) {
       switch (error.status) {
         case 401:
           return 'Authentication required. Please log in.'
         case 403:
           return 'Access denied. You do not have permission to view this resource.'
         case 404:
           return 'Resource not found.'
         case 429:
           return 'Too many requests. Please try again later.'
         case 500:
           return 'Server error. Please try again.'
         case 0:
           return 'Network error. Please check your internet connection.'
         default:
           return error.message || 'An unexpected error occurred.'
       }
     }

     if (error instanceof Error) {
       return error.message
     }

     return 'An unexpected error occurred.'
   }

   export function isNetworkError(error: unknown): boolean {
     return error instanceof ApiError && error.status === 0
   }

   export function isAuthError(error: unknown): boolean {
     return error instanceof ApiError && (error.status === 401 || error.status === 403)
   }
   ```

2. **Update auth store to handle logout**
   ```typescript
   // src/store/authStore.ts
   export const useAuthStore = create<AuthState>((set) => ({
     user: null,
     isAuthenticated: false,
     setUser: (user) => set({ user, isAuthenticated: !!user }),
     logout: () => {
       set({ user: null, isAuthenticated: false })
       // Clear any stored tokens
       document.cookie = 'access_token=; Max-Age=0; path=/;'
     },
   }))
   ```

### Task 5: Write Tests (0.5 days)

1. **Create `tests/services/api.test.ts`**
   ```typescript
   import { describe, it, expect, vi, beforeEach } from 'vitest'
   import { api, ApiError } from '../../src/services/api'
   import axios from 'axios'

   vi.mock('axios')

   describe('ApiClient', () => {
     beforeEach(() => {
       vi.clearAllMocks()
     })

     it('initializes with correct base URL', () => {
       expect(axios.create).toHaveBeenCalledWith(
         expect.objectContaining({
           baseURL: expect.stringContaining('/api'),
           timeout: 30000,
         })
       )
     })

     it('sends GET request correctly', async () => {
       const mockData = { projects: [] }
       vi.mocked(axios.create).mockReturnValue({
         request: vi.fn().mockResolvedValue({ data: mockData }),
         interceptors: { request: { use: vi.fn() }, response: { use: vi.fn() } },
       } as any)

       const result = await api.get('/projects')
       expect(result).toEqual(mockData)
     })

     it('handles 401 error by logging out', async () => {
       const error = {
         response: { status: 401, statusText: 'Unauthorized' },
       }

       vi.mocked(axios.create).mockReturnValue({
         request: vi.fn().mockRejectedValue(error),
         interceptors: { request: { use: vi.fn() }, response: { use: vi.fn() } },
       } as any)

       await expect(api.get('/protected')).rejects.toThrow(ApiError)
     })

     it('handles network error', async () => {
       const error = { request: {} }

       vi.mocked(axios.create).mockReturnValue({
         request: vi.fn().mockRejectedValue(error),
         interceptors: { request: { use: vi.fn() }, response: { use: vi.fn() } },
       } as any)

       await expect(api.get('/test')).rejects.toThrow('Network error')
     })
   })
   ```

---

## Dev Notes

### API Client Architecture

The API service layer provides:
- **Centralized HTTP logic**: All API calls go through one client
- **Type safety**: TypeScript interfaces for all requests/responses
- **Error handling**: Consistent error handling and user feedback
- **Token management**: Automatic JWT handling via cookies
- **Interceptors**: Request/response middleware for common tasks

### Environment Configuration

```env
# .env
VITE_API_URL=http://localhost:8000/api

# .env.production
VITE_API_URL=https://api.decisionlog.io/api
```

### Usage Example

```typescript
import { api } from './services/api'

// Login
try {
  const response = await api.login({
    email: 'user@example.com',
    password: 'password'
  })
  console.log('Logged in:', response.user)
} catch (error) {
  console.error(getErrorMessage(error))
}

// Get projects
const projects = await api.getProjects()
console.log(`Found ${projects.total} projects`)

// Get decisions with filters
const decisions = await api.getDecisions('project-id', {
  discipline: ['architecture', 'mep'],
  date_from: '2026-01-01',
  limit: 50
})
```

---

## File List

**Modified/Created:**
- `src/services/api.ts` (new) - API client implementation
- `src/types/api.ts` (new) - Request/response types
- `src/lib/errors.ts` (new) - Error handling utilities
- `src/store/authStore.ts` (modify) - Add logout method
- `tests/services/api.test.ts` (new) - Unit tests
- `package.json` (modify) - Add axios dependency

---

## Testing Strategy

### Unit Tests

```typescript
// Test coverage areas:
- ✅ API client initialization
- ✅ GET/POST/PATCH/DELETE methods
- ✅ Error handling (401, 403, 404, 500)
- ✅ Network error handling
- ✅ Token extraction from cookie
- ✅ Request interceptors
- ✅ Response interceptors
- ✅ Type safety validation
```

### Integration Tests

```bash
# Test with real backend (optional)
npm run test:integration

# Manual testing
npm run dev
# Try login, make API calls, check network tab
```

### Coverage Target

- Minimum: 80%
- Target: 90%+
- Run: `npm run test -- --coverage`

---

## UX Design System References

**Why This Matters for UX:**
- **Error Handling:** User-friendly error messages (not cryptic codes) improve trust and understanding
- **Type Safety:** Prevents frontend bugs where data doesn't load or displays wrong (bad UX)
- **Performance:** 30-second timeout prevents hung requests on slow mobile connections (Gabriela on iPad)
- **Security:** HTTP-only cookies + auto-logout on 401 protect user data without requiring frontend token management
- **Consistency:** Single API client ensures all frontend stories (Timeline, Filters, Digest, Drill-down) call backend the same way

**Frontend Dependency Chain:**
```
API Service Layer (3.2)
  ↓ enables ↓
Frontend Stories (3.4, 3.5, 3.6, 3.7, 3.8)
  ↓ depend on ↓
React Query (Story 3.1) + API Client (this story) for data fetching
```

---

## Change Log

| Date | Change |
|------|--------|
| 2026-02-08 | Created story |
| 2026-02-08 | Updated with UX context (error handling, type safety, performance for mobile) |

---

**Related Stories:** 3.1 (Frontend Setup), 3.3 (Authentication - uses API), 3.4-3.8 (All frontend features use this API)
**Blocked By:** 3.1 (Frontend Setup - needs project structure first)
**Blocks:** 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9 (all API-dependent frontend and backend stories)
