# Story 3.2: API Service Layer

**Story ID:** 3.2
**Assigned to:** @dev
**Sprint:** Sprint 4 (Week 6)
**Status:** Draft
**Estimation:** 3 story points (1-2 days)

---

## Summary

Create a centralized API service layer for all backend HTTP requests with TypeScript type safety, JWT token management, error handling, and request/response interceptors. This provides a consistent interface for all frontend-backend communication.

---

## Acceptance Criteria

- [ ] API client class implemented with TypeScript
- [ ] JWT token management:
  - [ ] Reads token from HTTP-only cookie
  - [ ] Falls back to Authorization header
  - [ ] Handles token refresh (if needed)
- [ ] Error handling:
  - [ ] 401 → Auto-logout and redirect to login
  - [ ] 403 → Show "Access Denied" message
  - [ ] 404 → Show "Not Found" error
  - [ ] 500 → Show "Server Error" with retry option
  - [ ] Network errors → Show offline message
- [ ] Request/response types defined (TypeScript interfaces)
- [ ] Base URL configurable via environment variable
- [ ] Timeout handling (30 seconds default)
- [ ] Request interceptors for common headers
- [ ] Response interceptors for error handling
- [ ] Tests passing: `npm run test` (80%+ coverage)

---

## Tasks

### Task 1: Create API Client Class (0.5 days)

1. **Create `src/services/api.ts`**
   ```typescript
   import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'
   import { useAuthStore } from '../store/authStore'

   class ApiClient {
     private client: AxiosInstance
     private baseUrl: string

     constructor() {
       this.baseUrl = import.meta.env.VITE_API_URL || 'http://localhost:8000/api'

       this.client = axios.create({
         baseURL: this.baseUrl,
         timeout: 30000, // 30 seconds
         withCredentials: true, // Send cookies
         headers: {
           'Content-Type': 'application/json',
         },
       })

       this.setupInterceptors()
     }

     private setupInterceptors() {
       // Request interceptor
       this.client.interceptors.request.use(
         (config) => {
           // Token automatically sent via cookie
           // But support Authorization header as fallback
           const token = this.getTokenFromCookie()
           if (token && !config.headers.Authorization) {
             config.headers.Authorization = `Bearer ${token}`
           }
           return config
         },
         (error) => Promise.reject(error)
       )

       // Response interceptor
       this.client.interceptors.response.use(
         (response) => response,
         (error) => {
           if (error.response?.status === 401) {
             // Unauthorized - logout and redirect
             useAuthStore.getState().logout()
             window.location.href = '/login'
           }
           return Promise.reject(error)
         }
       )
     }

     private getTokenFromCookie(): string | null {
       const cookies = document.cookie.split(';')
       const tokenCookie = cookies.find(c => c.trim().startsWith('access_token='))
       return tokenCookie ? tokenCookie.split('=')[1] : null
     }

     async request<T>(
       method: string,
       endpoint: string,
       data?: unknown,
       config?: AxiosRequestConfig
     ): Promise<T> {
       try {
         const response: AxiosResponse<T> = await this.client.request({
           method,
           url: endpoint,
           data,
           ...config,
         })
         return response.data
       } catch (error: any) {
         throw this.handleError(error)
       }
     }

     private handleError(error: any): ApiError {
       if (error.response) {
         // Server responded with error status
         return new ApiError(
           error.response.status,
           error.response.data?.detail || error.response.statusText,
           error.response.data
         )
       } else if (error.request) {
         // Request made but no response
         return new ApiError(0, 'Network error - please check your connection')
       } else {
         // Something else happened
         return new ApiError(0, error.message)
       }
     }

     // Convenience methods
     get<T>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
       return this.request<T>('GET', endpoint, undefined, config)
     }

     post<T>(endpoint: string, data?: unknown, config?: AxiosRequestConfig): Promise<T> {
       return this.request<T>('POST', endpoint, data, config)
     }

     patch<T>(endpoint: string, data?: unknown, config?: AxiosRequestConfig): Promise<T> {
       return this.request<T>('PATCH', endpoint, data, config)
     }

     delete<T>(endpoint: string, config?: AxiosRequestConfig): Promise<T> {
       return this.request<T>('DELETE', endpoint, undefined, config)
     }
   }

   export class ApiError extends Error {
     constructor(
       public status: number,
       public message: string,
       public data?: any
     ) {
       super(message)
       this.name = 'ApiError'
     }
   }

   // Export singleton instance
   export const api = new ApiClient()
   ```

2. **Test API client initialization**
   - Verify axios instance created
   - Check base URL from environment
   - Test interceptors registered

### Task 2: Define TypeScript Types (0.25 days)

1. **Create request/response types in `src/types/api.ts`**
   ```typescript
   import { User, Project, Decision } from './index'

   // Auth types
   export interface LoginRequest {
     email: string
     password: string
   }

   export interface LoginResponse {
     user: User
   }

   // Project types
   export interface ProjectsResponse {
     projects: Project[]
     total: number
     limit: number
     offset: number
   }

   export interface ProjectDetailResponse extends Project {
     members: ProjectMember[]
     stats: ProjectStats
   }

   export interface ProjectMember {
     user_id: string
     name: string
     email: string
     role: string
   }

   export interface ProjectStats {
     total_decisions: number
     decisions_last_week: number
     decisions_by_discipline: Record<string, number>
     decisions_by_meeting_type: Record<string, number>
   }

   // Decision types
   export interface DecisionsResponse {
     decisions: Decision[]
     total: number
     limit: number
     offset: number
     facets?: {
       disciplines: Record<string, number>
       meeting_types: Record<string, number>
     }
   }

   export interface DecisionDetailResponse extends Decision {
     similar_decisions?: SimilarDecision[]
     consistency_notes?: string
     transcript_excerpt?: TranscriptExcerpt
     meeting?: MeetingInfo
   }

   export interface SimilarDecision {
     decision_id: string
     similarity_score: number
     decision_statement: string
   }

   export interface TranscriptExcerpt {
     text: string
     start: string
     end: string
   }

   export interface MeetingInfo {
     id: string
     type: string
     date: string
     duration_minutes: number
     participants: Participant[]
   }

   export interface Participant {
     name: string
     email: string
     role: string
   }

   // Digest types
   export interface DigestResponse {
     project: {
       id: string
       name: string
     }
     period: {
       from: string
       to: string
     }
     summary: DigestSummary
     highlights: DigestHighlight[]
     anomalies: DigestAnomaly[]
   }

   export interface DigestSummary {
     total_decisions: number
     by_discipline: Record<string, number>
     high_impact_decisions: number
     decisions_with_dissent: number
   }

   export interface DigestHighlight {
     type: string
     count: number
     title: string
     description: string
     decision_ids: string[]
   }

   export interface DigestAnomaly {
     decision_id: string
     flag: string
     severity: 'low' | 'medium' | 'high'
     description: string
   }

   // Filter types
   export interface DecisionFilters {
     discipline?: string[]
     meeting_type?: string[]
     date_from?: string
     date_to?: string
     confidence_min?: number
     has_anomalies?: boolean
     search?: string
     limit?: number
     offset?: number
   }
   ```

### Task 3: Create API Service Methods (0.5 days)

1. **Add service methods to `src/services/api.ts`**
   ```typescript
   import {
     LoginRequest,
     LoginResponse,
     ProjectsResponse,
     ProjectDetailResponse,
     DecisionsResponse,
     DecisionDetailResponse,
     DigestResponse,
     DecisionFilters
   } from '../types/api'

   class ApiClient {
     // ... existing code ...

     // Auth endpoints
     async login(credentials: LoginRequest): Promise<LoginResponse> {
       return this.post<LoginResponse>('/auth/login', credentials)
     }

     async logout(): Promise<void> {
       return this.post<void>('/auth/logout')
     }

     async getCurrentUser(): Promise<User> {
       return this.get<User>('/auth/me')
     }

     // Project endpoints
     async getProjects(limit = 50, offset = 0): Promise<ProjectsResponse> {
       return this.get<ProjectsResponse>(`/projects?limit=${limit}&offset=${offset}`)
     }

     async getProject(projectId: string): Promise<ProjectDetailResponse> {
       return this.get<ProjectDetailResponse>(`/projects/${projectId}`)
     }

     // Decision endpoints
     async getDecisions(
       projectId: string,
       filters?: DecisionFilters
     ): Promise<DecisionsResponse> {
       const params = new URLSearchParams()
       if (filters?.discipline?.length) {
         params.append('discipline', filters.discipline.join(','))
       }
       if (filters?.meeting_type?.length) {
         params.append('meeting_type', filters.meeting_type.join(','))
       }
       if (filters?.date_from) params.append('date_from', filters.date_from)
       if (filters?.date_to) params.append('date_to', filters.date_to)
       if (filters?.search) params.append('search', filters.search)
       if (filters?.limit) params.append('limit', filters.limit.toString())
       if (filters?.offset) params.append('offset', filters.offset.toString())

       const query = params.toString()
       const url = `/projects/${projectId}/decisions${query ? `?${query}` : ''}`
       return this.get<DecisionsResponse>(url)
     }

     async getDecision(decisionId: string): Promise<DecisionDetailResponse> {
       return this.get<DecisionDetailResponse>(`/decisions/${decisionId}`)
     }

     // Digest endpoint
     async getDigest(
       projectId: string,
       fromDate: string,
       toDate: string
     ): Promise<DigestResponse> {
       return this.get<DigestResponse>(
         `/projects/${projectId}/digest?date_from=${fromDate}&date_to=${toDate}`
       )
     }
   }
   ```

### Task 4: Error Handling and User Feedback (0.25 days)

1. **Create error utility in `src/lib/errors.ts`**
   ```typescript
   import { ApiError } from '../services/api'

   export function getErrorMessage(error: unknown): string {
     if (error instanceof ApiError) {
       switch (error.status) {
         case 401:
           return 'Authentication required. Please log in.'
         case 403:
           return 'Access denied. You do not have permission to view this resource.'
         case 404:
           return 'Resource not found.'
         case 429:
           return 'Too many requests. Please try again later.'
         case 500:
           return 'Server error. Please try again.'
         case 0:
           return 'Network error. Please check your internet connection.'
         default:
           return error.message || 'An unexpected error occurred.'
       }
     }

     if (error instanceof Error) {
       return error.message
     }

     return 'An unexpected error occurred.'
   }

   export function isNetworkError(error: unknown): boolean {
     return error instanceof ApiError && error.status === 0
   }

   export function isAuthError(error: unknown): boolean {
     return error instanceof ApiError && (error.status === 401 || error.status === 403)
   }
   ```

2. **Update auth store to handle logout**
   ```typescript
   // src/store/authStore.ts
   export const useAuthStore = create<AuthState>((set) => ({
     user: null,
     isAuthenticated: false,
     setUser: (user) => set({ user, isAuthenticated: !!user }),
     logout: () => {
       set({ user: null, isAuthenticated: false })
       // Clear any stored tokens
       document.cookie = 'access_token=; Max-Age=0; path=/;'
     },
   }))
   ```

### Task 5: Write Tests (0.5 days)

1. **Create `tests/services/api.test.ts`**
   ```typescript
   import { describe, it, expect, vi, beforeEach } from 'vitest'
   import { api, ApiError } from '../../src/services/api'
   import axios from 'axios'

   vi.mock('axios')

   describe('ApiClient', () => {
     beforeEach(() => {
       vi.clearAllMocks()
     })

     it('initializes with correct base URL', () => {
       expect(axios.create).toHaveBeenCalledWith(
         expect.objectContaining({
           baseURL: expect.stringContaining('/api'),
           timeout: 30000,
         })
       )
     })

     it('sends GET request correctly', async () => {
       const mockData = { projects: [] }
       vi.mocked(axios.create).mockReturnValue({
         request: vi.fn().mockResolvedValue({ data: mockData }),
         interceptors: { request: { use: vi.fn() }, response: { use: vi.fn() } },
       } as any)

       const result = await api.get('/projects')
       expect(result).toEqual(mockData)
     })

     it('handles 401 error by logging out', async () => {
       const error = {
         response: { status: 401, statusText: 'Unauthorized' },
       }

       vi.mocked(axios.create).mockReturnValue({
         request: vi.fn().mockRejectedValue(error),
         interceptors: { request: { use: vi.fn() }, response: { use: vi.fn() } },
       } as any)

       await expect(api.get('/protected')).rejects.toThrow(ApiError)
     })

     it('handles network error', async () => {
       const error = { request: {} }

       vi.mocked(axios.create).mockReturnValue({
         request: vi.fn().mockRejectedValue(error),
         interceptors: { request: { use: vi.fn() }, response: { use: vi.fn() } },
       } as any)

       await expect(api.get('/test')).rejects.toThrow('Network error')
     })
   })
   ```

---

## Dev Notes

### API Client Architecture

The API service layer provides:
- **Centralized HTTP logic**: All API calls go through one client
- **Type safety**: TypeScript interfaces for all requests/responses
- **Error handling**: Consistent error handling and user feedback
- **Token management**: Automatic JWT handling via cookies
- **Interceptors**: Request/response middleware for common tasks

### Environment Configuration

```env
# .env
VITE_API_URL=http://localhost:8000/api

# .env.production
VITE_API_URL=https://api.decisionlog.io/api
```

### Usage Example

```typescript
import { api } from './services/api'

// Login
try {
  const response = await api.login({
    email: 'user@example.com',
    password: 'password'
  })
  console.log('Logged in:', response.user)
} catch (error) {
  console.error(getErrorMessage(error))
}

// Get projects
const projects = await api.getProjects()
console.log(`Found ${projects.total} projects`)

// Get decisions with filters
const decisions = await api.getDecisions('project-id', {
  discipline: ['architecture', 'mep'],
  date_from: '2026-01-01',
  limit: 50
})
```

---

## File List

**Modified/Created:**
- `src/services/api.ts` (new) - API client implementation
- `src/types/api.ts` (new) - Request/response types
- `src/lib/errors.ts` (new) - Error handling utilities
- `src/store/authStore.ts` (modify) - Add logout method
- `tests/services/api.test.ts` (new) - Unit tests
- `package.json` (modify) - Add axios dependency

---

## Testing Strategy

### Unit Tests

```typescript
// Test coverage areas:
- ✅ API client initialization
- ✅ GET/POST/PATCH/DELETE methods
- ✅ Error handling (401, 403, 404, 500)
- ✅ Network error handling
- ✅ Token extraction from cookie
- ✅ Request interceptors
- ✅ Response interceptors
- ✅ Type safety validation
```

### Integration Tests

```bash
# Test with real backend (optional)
npm run test:integration

# Manual testing
npm run dev
# Try login, make API calls, check network tab
```

### Coverage Target

- Minimum: 80%
- Target: 90%+
- Run: `npm run test -- --coverage`

---

## Change Log

| Date | Change |
|------|--------|
| 2026-02-08 | Created story |

---

**Related Stories:** 3.1 (Frontend Setup), 3.3 (Authentication)
**Blocked By:** 3.1
**Blocks:** 3.3, 3.4, 3.5 (all API-dependent frontend stories)
