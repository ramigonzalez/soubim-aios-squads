# Story 4.2: JWT Authentication Endpoint

**Story ID:** 4.2
**Assigned to:** @dev
**Sprint:** Sprint 6 (Week 8)
**Status:** Draft
**Estimation:** 5 story points (2-3 days)

---

## Summary

Implement JWT-based authentication endpoint (`POST /api/auth/login`) that validates credentials, generates JWT tokens with 24-hour expiration, stores tokens in HTTP-only cookies, and updates last_login_at timestamp.

---

## Acceptance Criteria

- [ ] `POST /api/auth/login` endpoint implemented
- [ ] Request validation (email, password required)
- [ ] Password verification with bcrypt
- [ ] JWT token generation (PyJWT):
  - [ ] Payload: user_id, role, exp (24h)
  - [ ] Secret key from environment variable
  - [ ] HS256 algorithm
- [ ] Token stored in HTTP-only cookie:
  - [ ] Name: access_token
  - [ ] Max-Age: 86400 (24 hours)
  - [ ] HttpOnly: true
  - [ ] Secure: true (HTTPS only in production)
  - [ ] SameSite: strict
- [ ] Response includes user info (id, email, name, role)
- [ ] last_login_at updated in database
- [ ] Generic error message (no user enumeration)
- [ ] Rate limiting: 5 attempts/min per IP
- [ ] Tests passing: `pytest tests/api/test_auth.py`

---

## Tasks

### Task 1: Create JWT Utilities (1 day)

```python
# app/utils/jwt.py
import jwt
from datetime import datetime, timedelta
from app.config import settings

def create_jwt_token(user_id: str, role: str, expires_in: int = 86400) -> str:
    payload = {
        "user_id": str(user_id),
        "role": role,
        "exp": datetime.utcnow() + timedelta(seconds=expires_in)
    }
    return jwt.encode(payload, settings.SECRET_KEY, algorithm="HS256")

def decode_jwt_token(token: str) -> dict:
    try:
        return jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
    except jwt.ExpiredSignatureError:
        raise ValueError("Token expired")
    except jwt.InvalidTokenError:
        raise ValueError("Invalid token")
```

### Task 2: Create Login Endpoint (1.5 days)

```python
# app/api/endpoints/auth.py
from fastapi import APIRouter, Depends, HTTPException, Response
from sqlalchemy.orm import Session
from app.database import get_db
from app.models.user import User
from app.utils.password import verify_password
from app.utils.jwt import create_jwt_token
from pydantic import BaseModel, EmailStr
from datetime import datetime

router = APIRouter(prefix="/auth", tags=["auth"])

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class LoginResponse(BaseModel):
    user: UserInfo

class UserInfo(BaseModel):
    id: str
    email: str
    name: str
    role: str

@router.post("/login", response_model=LoginResponse)
async def login(
    credentials: LoginRequest,
    response: Response,
    db: Session = Depends(get_db)
):
    # Find user
    user = db.query(User).filter(
        User.email == credentials.email,
        User.deleted_at.is_(None)
    ).first()
    
    # Verify password
    if not user or not verify_password(credentials.password, user.password_hash):
        raise HTTPException(
            status_code=401,
            detail="Invalid credentials"
        )
    
    # Generate JWT
    token = create_jwt_token(str(user.id), user.role)
    
    # Update last login
    user.last_login_at = datetime.utcnow()
    db.commit()
    
    # Set cookie
    response.set_cookie(
        key="access_token",
        value=token,
        max_age=86400,
        httponly=True,
        secure=True,  # HTTPS only in production
        samesite="strict"
    )
    
    return LoginResponse(
        user=UserInfo(
            id=str(user.id),
            email=user.email,
            name=user.name,
            role=user.role
        )
    )
```

### Task 3: Add Rate Limiting (0.5 days)

```python
# Install: pip install slowapi
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post("/login")
@limiter.limit("5/minute")
async def login(...):
    # ... existing code
```

### Task 4: Write Tests (1 day)

```python
# tests/api/test_auth.py
def test_login_success(client, test_user):
    response = client.post(
        "/api/auth/login",
        json={
            "email": "test@example.com",
            "password": "password"
        }
    )
    assert response.status_code == 200
    assert "user" in response.json()
    assert "access_token" in response.cookies

def test_login_invalid_password(client, test_user):
    response = client.post(
        "/api/auth/login",
        json={
            "email": "test@example.com",
            "password": "wrongpassword"
        }
    )
    assert response.status_code == 401
    assert response.json()["detail"] == "Invalid credentials"

def test_login_nonexistent_user(client):
    response = client.post(
        "/api/auth/login",
        json={
            "email": "nonexistent@example.com",
            "password": "password"
        }
    )
    assert response.status_code == 401

def test_rate_limiting(client, test_user):
    for i in range(6):
        response = client.post(
            "/api/auth/login",
            json={"email": "test@example.com", "password": "wrong"}
        )
    assert response.status_code == 429
```

---

## File List

**Modified/Created:**
- `app/utils/jwt.py` (new)
- `app/utils/password.py` (new - bcrypt utilities)
- `app/api/endpoints/auth.py` (new)
- `app/config.py` (modify - add SECRET_KEY)
- `tests/api/test_auth.py` (new)
- `requirements.txt` (modify - add PyJWT, slowapi)

---

**Related Stories:** 4.1 (User Schema), 4.3 (JWT Middleware)
**Blocked By:** 4.1
**Blocks:** 4.3
