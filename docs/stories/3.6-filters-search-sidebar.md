# Story 3.6: Filters & Search Sidebar

**Story ID:** 3.6
**Assigned to:** @dev
**Sprint:** Sprint 5 (Week 7)
**Status:** Draft
**Estimation:** 8 story points (3-4 days)

---

## Summary

Create a comprehensive filters sidebar for decisions timeline with date range picker, multi-select filters for discipline/meeting type/impact/consensus, free-text search, and active filter indicators. All filters work together with <200ms update performance.

---

## Acceptance Criteria

- [ ] Filter sidebar component with collapsible sections
- [ ] Date range picker (from/to dates)
- [ ] Multi-select checkboxes for:
  - [ ] Discipline (Architecture, MEP, Landscape, etc.)
  - [ ] Meeting type (Client, Multi-disc, Internal)
  - [ ] Impact level (High, Medium, Low)
  - [ ] Consensus level (High, Medium, Low)
- [ ] Free-text search input (searches statement + why fields)
- [ ] Combined filtering (all filters work together)
- [ ] Active filter indicators with counts
- [ ] Clear all filters button
- [ ] Filter persistence in URL query params
- [ ] Performance: <200ms per filter change
- [ ] Responsive: Drawer on mobile, sidebar on desktop
- [ ] Tests passing: `npm run test` (80%+ coverage)

---

## Tasks

### Task 1: Create Filter Store (0.5 days)

1. **Create `src/store/filterStore.ts`**
   ```typescript
   import { create } from 'zustand'
   import { DecisionFilters } from '../types/api'

   interface FilterState {
     filters: DecisionFilters
     setFilter: <K extends keyof DecisionFilters>(key: K, value: DecisionFilters[K]) => void
     clearFilters: () => void
     activeCount: () => number
   }

   const DEFAULT_FILTERS: DecisionFilters = {
     discipline: [],
     meeting_type: [],
     date_from: undefined,
     date_to: undefined,
     confidence_min: undefined,
     has_anomalies: undefined,
     search: '',
   }

   export const useFilterStore = create<FilterState>((set, get) => ({
     filters: DEFAULT_FILTERS,

     setFilter: (key, value) => {
       set((state) => ({
         filters: { ...state.filters, [key]: value },
       }))
     },

     clearFilters: () => set({ filters: DEFAULT_FILTERS }),

     activeCount: () => {
       const { filters } = get()
       let count = 0
       if (filters.discipline && filters.discipline.length > 0) count++
       if (filters.meeting_type && filters.meeting_type.length > 0) count++
       if (filters.date_from) count++
       if (filters.date_to) count++
       if (filters.search) count++
       if (filters.has_anomalies !== undefined) count++
       return count
     },
   }))
   ```

### Task 2: Create Filter Sidebar Component (1.5 days)

1. **Create `src/components/FilterSidebar.tsx`**
   ```typescript
   import { useFilterStore } from '../store/filterStore'
   import { Button } from './ui/button'
   import { Input } from './ui/input'
   import { Label } from './ui/label'
   import { Checkbox } from './ui/checkbox'
   import { Badge } from './ui/badge'
   import {
     Accordion,
     AccordionContent,
     AccordionItem,
     AccordionTrigger,
   } from './ui/accordion'
   import { Filter, X } from 'lucide-react'

   const DISCIPLINES = [
     { value: 'architecture', label: 'Architecture' },
     { value: 'mep', label: 'MEP' },
     { value: 'landscape', label: 'Landscape' },
     { value: 'structural', label: 'Structural' },
     { value: 'electrical', label: 'Electrical' },
     { value: 'plumbing', label: 'Plumbing' },
     { value: 'general', label: 'General' },
   ]

   const MEETING_TYPES = [
     { value: 'client', label: 'Client' },
     { value: 'multi-disciplinary', label: 'Multi-disciplinary' },
     { value: 'internal', label: 'Internal' },
   ]

   export function FilterSidebar() {
     const { filters, setFilter, clearFilters, activeCount } = useFilterStore()

     const handleDisciplineToggle = (discipline: string) => {
       const current = filters.discipline || []
       const updated = current.includes(discipline)
         ? current.filter((d) => d !== discipline)
         : [...current, discipline]
       setFilter('discipline', updated)
     }

     const handleMeetingTypeToggle = (type: string) => {
       const current = filters.meeting_type || []
       const updated = current.includes(type)
         ? current.filter((t) => t !== type)
         : [...current, type]
       setFilter('meeting_type', updated)
     }

     return (
       <aside className="w-80 bg-white border-r border-gray-200 p-6 overflow-y-auto">
         <div className="flex items-center justify-between mb-6">
           <div className="flex items-center gap-2">
             <Filter className="h-5 w-5" />
             <h2 className="text-lg font-semibold">Filters</h2>
             {activeCount() > 0 && (
               <Badge variant="secondary">{activeCount()}</Badge>
             )}
           </div>

           {activeCount() > 0 && (
             <Button
               variant="ghost"
               size="sm"
               onClick={clearFilters}
               className="text-gray-600 hover:text-gray-900"
             >
               <X className="h-4 w-4 mr-1" />
               Clear
             </Button>
           )}
         </div>

         <div className="space-y-6">
           {/* Search */}
           <div>
             <Label htmlFor="search">Search</Label>
             <Input
               id="search"
               type="text"
               placeholder="Search decisions..."
               value={filters.search || ''}
               onChange={(e) => setFilter('search', e.target.value)}
               className="mt-2"
             />
           </div>

           {/* Accordion for filter groups */}
           <Accordion type="multiple" defaultValue={['discipline', 'meeting_type']}>
             {/* Discipline Filter */}
             <AccordionItem value="discipline">
               <AccordionTrigger>Discipline</AccordionTrigger>
               <AccordionContent>
                 <div className="space-y-2">
                   {DISCIPLINES.map((discipline) => (
                     <div key={discipline.value} className="flex items-center">
                       <Checkbox
                         id={`discipline-${discipline.value}`}
                         checked={filters.discipline?.includes(discipline.value)}
                         onCheckedChange={() => handleDisciplineToggle(discipline.value)}
                       />
                       <Label
                         htmlFor={`discipline-${discipline.value}`}
                         className="ml-2 text-sm cursor-pointer"
                       >
                         {discipline.label}
                       </Label>
                     </div>
                   ))}
                 </div>
               </AccordionContent>
             </AccordionItem>

             {/* Meeting Type Filter */}
             <AccordionItem value="meeting_type">
               <AccordionTrigger>Meeting Type</AccordionTrigger>
               <AccordionContent>
                 <div className="space-y-2">
                   {MEETING_TYPES.map((type) => (
                     <div key={type.value} className="flex items-center">
                       <Checkbox
                         id={`meeting-${type.value}`}
                         checked={filters.meeting_type?.includes(type.value)}
                         onCheckedChange={() => handleMeetingTypeToggle(type.value)}
                       />
                       <Label
                         htmlFor={`meeting-${type.value}`}
                         className="ml-2 text-sm cursor-pointer"
                       >
                         {type.label}
                       </Label>
                     </div>
                   ))}
                 </div>
               </AccordionContent>
             </AccordionItem>

             {/* Date Range Filter */}
             <AccordionItem value="date_range">
               <AccordionTrigger>Date Range</AccordionTrigger>
               <AccordionContent>
                 <div className="space-y-3">
                   <div>
                     <Label htmlFor="date_from">From</Label>
                     <Input
                       id="date_from"
                       type="date"
                       value={filters.date_from || ''}
                       onChange={(e) => setFilter('date_from', e.target.value)}
                       className="mt-1"
                     />
                   </div>
                   <div>
                     <Label htmlFor="date_to">To</Label>
                     <Input
                       id="date_to"
                       type="date"
                       value={filters.date_to || ''}
                       onChange={(e) => setFilter('date_to', e.target.value)}
                       className="mt-1"
                     />
                   </div>
                 </div>
               </AccordionContent>
             </AccordionItem>

             {/* Anomalies Filter */}
             <AccordionItem value="anomalies">
               <AccordionTrigger>Anomalies</AccordionTrigger>
               <AccordionContent>
                 <div className="flex items-center">
                   <Checkbox
                     id="has_anomalies"
                     checked={filters.has_anomalies === true}
                     onCheckedChange={(checked) =>
                       setFilter('has_anomalies', checked ? true : undefined)
                     }
                   />
                   <Label htmlFor="has_anomalies" className="ml-2 text-sm cursor-pointer">
                     Show only flagged decisions
                   </Label>
                 </div>
               </AccordionContent>
             </AccordionItem>
           </Accordion>
         </div>
       </aside>
     )
   }
   ```

2. **Install Shadcn components**
   ```bash
   npx shadcn-ui@latest add checkbox
   npx shadcn-ui@latest add accordion
   ```

### Task 3: Connect Filters to Timeline (1 day)

1. **Update Timeline to use filters**
   ```typescript
   // src/components/Timeline.tsx
   import { useFilterStore } from '../store/filterStore'

   export function Timeline() {
     const { id: projectId } = useParams<{ id: string }>()
     const filters = useFilterStore((state) => state.filters)

     const {
       data: decisionsData,
       isLoading,
       isError,
       error,
       refetch
     } = useQuery({
       queryKey: ['decisions', projectId, filters],
       queryFn: () => api.getDecisions(projectId!, filters),
       enabled: !!projectId,
     })

     // ... rest of component
   }
   ```

2. **Add debouncing for search input**
   ```typescript
   import { useDebouncedValue } from '../hooks/useDebouncedValue'

   // In FilterSidebar:
   const debouncedSearch = useDebouncedValue(filters.search, 300)

   useEffect(() => {
     setFilter('search', debouncedSearch)
   }, [debouncedSearch])
   ```

3. **Create `src/hooks/useDebouncedValue.ts`**
   ```typescript
   import { useEffect, useState } from 'react'

   export function useDebouncedValue<T>(value: T, delay: number): T {
     const [debouncedValue, setDebouncedValue] = useState<T>(value)

     useEffect(() => {
       const handler = setTimeout(() => {
         setDebouncedValue(value)
       }, delay)

       return () => {
         clearTimeout(handler)
       }
     }, [value, delay])

     return debouncedValue
   }
   ```

### Task 4: Add URL Persistence (0.5 days)

1. **Sync filters with URL query params**
   ```typescript
   // src/hooks/useFilterSync.ts
   import { useEffect } from 'react'
   import { useSearchParams } from 'react-router-dom'
   import { useFilterStore } from '../store/filterStore'

   export function useFilterSync() {
     const [searchParams, setSearchParams] = useSearchParams()
     const { filters, setFilter } = useFilterStore()

     // Load filters from URL on mount
     useEffect(() => {
       const discipline = searchParams.get('discipline')?.split(',')
       const meeting_type = searchParams.get('meeting_type')?.split(',')
       const date_from = searchParams.get('date_from')
       const date_to = searchParams.get('date_to')
       const search = searchParams.get('search')

       if (discipline) setFilter('discipline', discipline)
       if (meeting_type) setFilter('meeting_type', meeting_type)
       if (date_from) setFilter('date_from', date_from)
       if (date_to) setFilter('date_to', date_to)
       if (search) setFilter('search', search)
     }, [])

     // Update URL when filters change
     useEffect(() => {
       const params = new URLSearchParams()

       if (filters.discipline?.length) {
         params.set('discipline', filters.discipline.join(','))
       }
       if (filters.meeting_type?.length) {
         params.set('meeting_type', filters.meeting_type.join(','))
       }
       if (filters.date_from) params.set('date_from', filters.date_from)
       if (filters.date_to) params.set('date_to', filters.date_to)
       if (filters.search) params.set('search', filters.search)

       setSearchParams(params, { replace: true })
     }, [filters])
   }
   ```

### Task 5: Write Tests (0.5 days)

1. **Create `tests/components/FilterSidebar.test.tsx`**
   ```typescript
   import { describe, it, expect } from 'vitest'
   import { render, screen, fireEvent } from '@testing-library/react'
   import { FilterSidebar } from '../../src/components/FilterSidebar'
   import { useFilterStore } from '../../src/store/filterStore'

   describe('FilterSidebar', () => {
     beforeEach(() => {
       useFilterStore.getState().clearFilters()
     })

     it('renders all filter sections', () => {
       render(<FilterSidebar />)

       expect(screen.getByText('Filters')).toBeInTheDocument()
       expect(screen.getByLabelText('Search')).toBeInTheDocument()
       expect(screen.getByText('Discipline')).toBeInTheDocument()
       expect(screen.getByText('Meeting Type')).toBeInTheDocument()
       expect(screen.getByText('Date Range')).toBeInTheDocument()
     })

     it('toggles discipline filter', () => {
       render(<FilterSidebar />)

       const architectureCheckbox = screen.getByLabelText('Architecture')
       fireEvent.click(architectureCheckbox)

       const { filters } = useFilterStore.getState()
       expect(filters.discipline).toContain('architecture')
     })

     it('updates search filter', () => {
       render(<FilterSidebar />)

       const searchInput = screen.getByLabelText('Search')
       fireEvent.change(searchInput, { target: { value: 'foundation' } })

       const { filters } = useFilterStore.getState()
       expect(filters.search).toBe('foundation')
     })

     it('clears all filters', () => {
       const { setFilter } = useFilterStore.getState()
       setFilter('discipline', ['architecture'])
       setFilter('search', 'test')

       render(<FilterSidebar />)

       const clearButton = screen.getByText('Clear')
       fireEvent.click(clearButton)

       const { filters, activeCount } = useFilterStore.getState()
       expect(activeCount()).toBe(0)
       expect(filters.discipline).toEqual([])
       expect(filters.search).toBe('')
     })

     it('shows active filter count', () => {
       const { setFilter } = useFilterStore.getState()
       setFilter('discipline', ['architecture', 'mep'])

       render(<FilterSidebar />)

       expect(screen.getByText('2')).toBeInTheDocument()
     })
   })
   ```

---

## Dev Notes

### Filter Architecture

```
FilterSidebar
├── Search input (debounced 300ms)
├── Discipline checkboxes (multi-select)
├── Meeting Type checkboxes (multi-select)
├── Date Range (from/to)
├── Anomalies toggle
└── Clear All button

FilterStore (Zustand)
├── filters state
├── setFilter(key, value)
├── clearFilters()
└── activeCount()

Timeline
└── useQuery(['decisions', projectId, filters])
    └── Refetches when filters change
```

### Performance Optimization

- **Debounced search**: 300ms delay prevents API spam
- **React Query cache**: Filters changes cached separately
- **Target**: <200ms filter update
- **URL sync**: Filters preserved in query params (shareable)

---

## File List

**Modified/Created:**
- `src/components/FilterSidebar.tsx` (new) - Filter sidebar
- `src/store/filterStore.ts` (new) - Filter state management
- `src/hooks/useDebouncedValue.ts` (new) - Debounce hook
- `src/hooks/useFilterSync.ts` (new) - URL sync hook
- `src/components/Timeline.tsx` (modify) - Connect filters
- `tests/components/FilterSidebar.test.tsx` (new) - Tests
- `package.json` (modify) - Dependencies

---

## Testing Strategy

### Unit Tests

```typescript
// Test coverage areas:
- ✅ Filter sidebar rendering
- ✅ Discipline filter toggle
- ✅ Meeting type filter toggle
- ✅ Date range selection
- ✅ Search input update
- ✅ Clear filters button
- ✅ Active filter count
- ✅ URL persistence
- ✅ Debounced search
```

### Performance Testing

```bash
# Measure filter update time
# Target: <200ms from filter change to UI update
```

### Coverage Target

- Minimum: 80%
- Target: 90%+
- Run: `npm run test -- --coverage`

---

## Change Log

| Date | Change |
|------|--------|
| 2026-02-08 | Created story |

---

**Related Stories:** 3.5 (Timeline), 3.9 (API Endpoints)
**Blocked By:** 3.5
**Blocks:** None
