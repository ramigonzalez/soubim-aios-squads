# Story 4.4: Role-Based Authorization

**Story ID:** 4.4
**Assigned to:** @dev
**Sprint:** Sprint 6 (Week 8)
**Status:** Draft
**Estimation:** 5 story points (2-3 days)

---

## Summary

Implement role-based authorization with decorator/middleware to restrict endpoint access based on user roles (director, architect, client). Directors have full access, architects have project-specific access, clients have view-only access.

---

## Acceptance Criteria

- [ ] Role authorization decorator created
- [ ] Role checking on protected endpoints:
  - [ ] Directors: All projects, all decisions (full access)
  - [ ] Architects: Assigned projects only (read/write)
  - [ ] Clients: Assigned projects (read-only)
- [ ] Returns 403 (Forbidden) if role insufficient
- [ ] Endpoints protected:
  - [ ] GET /api/projects (director only for all, architects see assigned)
  - [ ] GET /api/projects/{id} (access check)
  - [ ] GET /api/projects/{id}/decisions (access check)
- [ ] Tests passing: `pytest tests/api/test_authorization.py`

---

## Tasks

### Task 1: Create Authorization Decorator (1 day)

```python
# app/utils/authorization.py
from functools import wraps
from fastapi import HTTPException, Request

def require_role(*allowed_roles: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            request = kwargs.get('request') or args[0]
            user = getattr(request.state, 'user', None)
            
            if not user:
                raise HTTPException(status_code=401, detail="Unauthorized")
            
            if user.role not in allowed_roles:
                raise HTTPException(
                    status_code=403,
                    detail=f"Access denied. Required roles: {', '.join(allowed_roles)}"
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# Usage:
@app.get("/api/admin/users")
@require_role("director")
async def list_all_users(request: Request, db: Session = Depends(get_db)):
    # Only directors can access
    pass
```

### Task 2: Update Project Endpoints (1 day)

```python
# app/api/endpoints/projects.py
@router.get("/projects")
async def list_projects(
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # Directors see all projects
    if current_user.role == "director":
        projects = db.query(Project).all()
    else:
        # Architects/clients see assigned projects only
        project_ids = db.query(UserProject.project_id).filter(
            UserProject.user_id == current_user.id
        ).all()
        projects = db.query(Project).filter(
            Project.id.in_([p[0] for p in project_ids])
        ).all()
    
    return {"projects": [ProjectResponse.from_orm(p) for p in projects]}
```

### Task 3: Write Tests (1 day)

```python
# tests/api/test_authorization.py
def test_director_can_access_all_projects(client, director_token):
    response = client.get(
        "/api/projects",
        headers={"Authorization": f"Bearer {director_token}"}
    )
    assert response.status_code == 200

def test_architect_sees_only_assigned_projects(client, architect_token, test_project):
    response = client.get(
        "/api/projects",
        headers={"Authorization": f"Bearer {architect_token}"}
    )
    assert response.status_code == 200
    projects = response.json()["projects"]
    # Should only see assigned projects
    assert len(projects) <= 1

def test_architect_cannot_access_unassigned_project(client, architect_token, other_project):
    response = client.get(
        f"/api/projects/{other_project.id}",
        headers={"Authorization": f"Bearer {architect_token}"}
    )
    assert response.status_code == 403
```

---

**Related Stories:** 4.3 (JWT Middleware), 4.5 (Project Access Control)
**Blocked By:** 4.3
**Blocks:** 4.5
