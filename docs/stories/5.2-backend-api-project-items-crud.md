# Story 5.2: Backend API — Project Items CRUD

**Story ID:** 5.2
**Epic:** E5 — Data Model Evolution & Project Item Taxonomy
**Assigned to:** @dev
**Sprint:** Sprint 1 (Week 1)
**Status:** Draft
**Estimation:** 8 story points (3 days)
**Review:** @architect (Aria) — API design validation
**Co-dependent:** Story 5.3 (Frontend Types) — must deploy together (Architect Blocker B5)

---

## Summary

Create new REST API endpoints for Project Items that replace the V1 decisions endpoints. Includes full CRUD with advanced filtering (item_type, source_type, discipline, date range, search, milestone), backward-compatible `/decisions` proxy endpoint with response transformation, and Pydantic request/response models with structured `impacts` and `consensus` schemas. All endpoints respect existing JWT auth and role-based access.

---

## Acceptance Criteria

### New Endpoints
- [ ] `GET /api/projects/{id}/items` — List project items with full filter support
  - [ ] Query params: `item_type`, `source_type`, `discipline`, `is_milestone`, `date_from`, `date_to`, `search`, `sort_by`, `sort_order`, `limit`, `offset`
  - [ ] Multiple values for `item_type`, `source_type`, `discipline` (comma-separated)
  - [ ] `discipline` filter uses JSONB `@>` operator against `affected_disciplines`
  - [ ] `search` searches across `statement`, `who`, `why` fields
  - [ ] Response includes `total`, `limit`, `offset`, `facets` (counts by item_type, source_type, discipline)
- [ ] `GET /api/projects/{id}/items/{item_id}` — Get single item detail
  - [ ] Returns full item including structured `impacts`, `consensus`, `source_excerpt`
  - [ ] Includes source information (title, type, occurred_at) via JOIN
  - [ ] Includes `affected_disciplines` as array of discipline strings
- [ ] `POST /api/projects/{id}/items` — Create manual input item
  - [ ] Required: `statement`, `item_type`, `who`, `affected_disciplines[]`
  - [ ] Optional: `why`, `causation`, `owner` (action_items), `is_done`, context fields
  - [ ] Auto-sets `source_type='manual_input'`
  - [ ] Generates vector embedding on creation
  - [ ] Returns created item with ID
- [ ] `PATCH /api/projects/{id}/items/{item_id}` — Update item
  - [ ] Supports: `is_milestone` toggle, `is_done` toggle, `statement` edit
  - [ ] Admin-only for `is_milestone` toggle
  - [ ] Returns updated item
- [ ] `GET /api/projects/{id}/milestones` — List milestone-only items
  - [ ] Equivalent to `/items?is_milestone=true`
  - [ ] Supports same filter params as `/items`

### Backward-Compatible Endpoint
- [ ] `GET /api/projects/{id}/decisions` — Preserved from V1
  - [ ] Internally queries `project_items WHERE item_type='decision'`
  - [ ] Response key: `"decisions"` (not `"items"`)
  - [ ] Field mapping transformation:
    - `statement` → `decision_statement`
    - `affected_disciplines[0]` → `discipline`
    - `source.title` → `meeting_title`
    - `source.occurred_at` → `meeting_date`
    - `source.meeting_type` → `meeting_type`
    - `source.participants` → `meeting_participants`
    - `source_id` → also returns `transcript_id` (legacy mapping)
  - [ ] Existing V1 query params still work: `discipline`, `meeting_type`, `date_from`, `date_to`, `search`, `confidence_min`, `has_anomalies`
  - [ ] Response includes `Deprecation: true` header

### Pydantic Models
- [ ] `ProjectItemResponse` — Full item response model
- [ ] `ProjectItemCreate` — Manual input creation model
- [ ] `ProjectItemUpdate` — Partial update model
- [ ] `ProjectItemListResponse` — Paginated list with facets
- [ ] `ImpactsSchema` — Structured impacts: `cost_impact`, `timeline_impact`, `scope_impact`, `risk_level`, `affected_areas[]`
- [ ] `ConsensusSchema` — Flat map: `{discipline: {status: "AGREE"|"DISAGREE"|"ABSTAIN", notes: str?}}`
- [ ] `DecisionResponse` — V1-compatible response for `/decisions` endpoint
- [ ] All models have proper validation (item_type enum, discipline enum, etc.)

### Auth & Access Control
- [ ] All endpoints require JWT authentication
- [ ] `is_milestone` toggle restricted to admin/director role
- [ ] Project-level access control: user must be member of project
- [ ] Manual item creation: any project member

---

## Tasks

### Task 1: Create Pydantic Models (0.5 days)

1. **Create `decision-log-backend/app/api/models/project_item.py`**
   ```python
   from pydantic import BaseModel, Field
   from typing import Optional, List
   from enum import Enum
   from datetime import datetime

   class ItemType(str, Enum):
       IDEA = "idea"
       TOPIC = "topic"
       DECISION = "decision"
       ACTION_ITEM = "action_item"
       INFORMATION = "information"

   class SourceType(str, Enum):
       MEETING = "meeting"
       EMAIL = "email"
       DOCUMENT = "document"
       MANUAL_INPUT = "manual_input"

   class Discipline(str, Enum):
       ARCHITECTURE = "architecture"
       STRUCTURAL = "structural"
       MEP = "mep"
       ELECTRICAL = "electrical"
       PLUMBING = "plumbing"
       LANDSCAPE = "landscape"
       FIRE_PROTECTION = "fire_protection"
       ACOUSTICAL = "acoustical"
       SUSTAINABILITY = "sustainability"
       CIVIL = "civil"
       CLIENT = "client"
       CONTRACTOR = "contractor"
       TENANT = "tenant"
       ENGINEER = "engineer"
       GENERAL = "general"

   class ConsensusEntry(BaseModel):
       status: str = Field(..., pattern="^(AGREE|DISAGREE|ABSTAIN)$")
       notes: Optional[str] = None

   class ImpactsSchema(BaseModel):
       cost_impact: Optional[str] = None
       timeline_impact: Optional[str] = None
       scope_impact: Optional[str] = None
       risk_level: Optional[str] = Field(None, pattern="^(low|medium|high)$")
       affected_areas: Optional[List[str]] = None

   class ProjectItemCreate(BaseModel):
       statement: str
       item_type: ItemType
       who: str
       affected_disciplines: List[Discipline]
       why: Optional[str] = None
       causation: Optional[str] = None
       owner: Optional[str] = None  # for action_items
       is_done: bool = False
       impacts: Optional[ImpactsSchema] = None
       consensus: Optional[dict[str, ConsensusEntry]] = None

   class ProjectItemUpdate(BaseModel):
       is_milestone: Optional[bool] = None
       is_done: Optional[bool] = None
       statement: Optional[str] = None

   class ProjectItemResponse(BaseModel):
       id: str
       project_id: str
       statement: str
       who: str
       timestamp: Optional[str] = None
       item_type: str
       source_type: str
       affected_disciplines: List[str]
       is_milestone: bool
       is_done: bool
       owner: Optional[str] = None
       why: Optional[str] = None
       causation: Optional[str] = None
       impacts: Optional[dict] = None
       consensus: Optional[dict] = None
       confidence: Optional[float] = None
       source_excerpt: Optional[str] = None
       source: Optional[dict] = None  # {title, type, occurred_at}
       created_at: str
       updated_at: Optional[str] = None

   class ProjectItemListResponse(BaseModel):
       items: List[ProjectItemResponse]
       total: int
       limit: int
       offset: int
       facets: Optional[dict] = None
   ```

### Task 2: Create Project Items Router (1.5 days)

1. **Create `decision-log-backend/app/api/routes/project_items.py`**
   - `GET /api/projects/{project_id}/items` with all filters
   - `GET /api/projects/{project_id}/items/{item_id}` with source JOIN
   - `POST /api/projects/{project_id}/items` for manual input
   - `PATCH /api/projects/{project_id}/items/{item_id}` for updates
   - `GET /api/projects/{project_id}/milestones` shortcut

2. **Filter implementation**
   ```python
   # Multi-value filter: ?item_type=decision,topic
   if item_type:
       types = item_type.split(',')
       query = query.filter(ProjectItem.item_type.in_(types))

   # JSONB discipline filter: ?discipline=structural
   if discipline:
       disciplines = discipline.split(',')
       for d in disciplines:
           query = query.filter(
               ProjectItem.affected_disciplines.contains(f'["{d}"]')
           )

   # Text search across multiple fields
   if search:
       search_term = f"%{search}%"
       query = query.filter(
           or_(
               ProjectItem.statement.ilike(search_term),
               ProjectItem.who.ilike(search_term),
               ProjectItem.why.ilike(search_term),
           )
       )
   ```

3. **Facets calculation**
   ```python
   # Count by item_type
   facets = {
       "item_types": dict(db.query(ProjectItem.item_type, func.count())
           .filter(ProjectItem.project_id == project_id)
           .group_by(ProjectItem.item_type).all()),
       "source_types": dict(db.query(ProjectItem.source_type, func.count())
           .filter(ProjectItem.project_id == project_id)
           .group_by(ProjectItem.source_type).all()),
   }
   ```

### Task 3: Update Decisions Endpoint for Backward Compatibility (0.5 days)

1. **Modify `decision-log-backend/app/api/routes/decisions.py`**
   - Keep existing route path `/api/projects/{project_id}/decisions`
   - Internally query `ProjectItem` where `item_type='decision'`
   - Transform response: map V2 field names back to V1 names
   - Add `Deprecation: true` response header
   - Preserve all existing query params

   ```python
   @router.get("/projects/{project_id}/decisions")
   async def get_decisions_v1_compat(project_id: str, ...):
       """V1 backward-compatible endpoint. Proxies to project_items."""
       items = query_project_items(project_id, item_type='decision', ...)

       # Transform to V1 response shape
       decisions = []
       for item in items:
           decisions.append({
               "id": str(item.id),
               "decision_statement": item.statement,
               "discipline": item.affected_disciplines[0] if item.affected_disciplines else "general",
               "meeting_title": item.source.title if item.source else None,
               "meeting_date": str(item.source.occurred_at) if item.source else None,
               "meeting_type": item.source.meeting_type if item.source else None,
               "meeting_participants": item.source.participants if item.source else None,
               "transcript_id": str(item.transcript_id) if item.transcript_id else None,
               # Pass through unchanged fields
               "who": item.who, "timestamp": item.timestamp,
               "why": item.why, "causation": item.causation,
               "consensus": item.consensus, "impacts": item.impacts,
               "confidence": item.confidence,
               "created_at": str(item.created_at),
           })

       response = JSONResponse({"decisions": decisions, "total": total, ...})
       response.headers["Deprecation"] = "true"
       return response
   ```

### Task 4: Register Routes & Write Tests (0.5 days)

1. **Register new router in `app/main.py`**
   ```python
   from app.api.routes.project_items import router as items_router
   app.include_router(items_router, prefix="/api")
   ```

2. **Create `tests/unit/test_project_items_api.py`**
   - Test: GET /items returns all project items
   - Test: GET /items?item_type=decision filters correctly
   - Test: GET /items?discipline=structural uses JSONB contains
   - Test: GET /items?search=concrete searches across fields
   - Test: GET /items/{id} returns full detail with source
   - Test: POST /items creates manual input item
   - Test: PATCH /items/{id} toggles milestone (admin only)
   - Test: PATCH /items/{id} toggles is_done
   - Test: GET /milestones returns only milestone items
   - Test: GET /decisions returns V1-compatible response shape
   - Test: GET /decisions response has `decision_statement` not `statement`
   - Test: Auth required on all endpoints
   - Test: Non-member cannot access project items

---

## Dev Notes

### API Response Examples

**GET /api/projects/{id}/items**
```json
{
  "items": [
    {
      "id": "uuid",
      "project_id": "uuid",
      "statement": "Changed structural material from concrete to steel",
      "who": "Carlos (Structural Engineer)",
      "timestamp": "00:23:15",
      "item_type": "decision",
      "source_type": "meeting",
      "affected_disciplines": ["structural", "architecture"],
      "is_milestone": true,
      "is_done": false,
      "why": "Client requested lighter structure for seismic performance",
      "impacts": {
        "cost_impact": "+$50K for steel vs concrete",
        "timeline_impact": "+2 weeks for steel delivery",
        "risk_level": "medium"
      },
      "consensus": {
        "architecture": {"status": "AGREE", "notes": null},
        "structural": {"status": "AGREE", "notes": "Preferred option"},
        "mep": {"status": "AGREE", "notes": null}
      },
      "confidence": 0.92,
      "source": {
        "id": "uuid",
        "title": "Multi-disciplinary Coordination Meeting",
        "type": "meeting",
        "occurred_at": "2026-02-01T14:00:00Z"
      },
      "created_at": "2026-02-01T14:45:00Z"
    }
  ],
  "total": 127,
  "limit": 50,
  "offset": 0,
  "facets": {
    "item_types": {"decision": 85, "topic": 20, "action_item": 15, "idea": 5, "information": 2},
    "source_types": {"meeting": 120, "manual_input": 7},
    "disciplines": {"architecture": 45, "structural": 32, "mep": 28}
  }
}
```

**POST /api/projects/{id}/items (Manual Input)**
```json
{
  "statement": "Client mentioned interest in green roof options",
  "item_type": "idea",
  "who": "Gabriela",
  "affected_disciplines": ["landscape", "architecture"],
  "why": "Mentioned during informal site visit conversation"
}
```

### Route File Organization

```
app/api/routes/
├── project_items.py   (NEW — primary V2 endpoint)
├── decisions.py       (MODIFIED — backward compat wrapper)
├── projects.py        (existing)
├── auth.py            (existing)
└── webhooks.py        (existing)
```

---

## File List

**New Files:**
- `decision-log-backend/app/api/models/project_item.py` — Pydantic models
- `decision-log-backend/app/api/routes/project_items.py` — V2 items router
- `decision-log-backend/tests/unit/test_project_items_api.py` — API tests

**Modified Files:**
- `decision-log-backend/app/api/routes/decisions.py` — Backward compat transformation
- `decision-log-backend/app/main.py` — Register new router

---

## Testing Strategy

### Unit Tests
```
- ✅ All 5 CRUD endpoints respond correctly
- ✅ Multi-value filters (item_type, source_type, discipline)
- ✅ JSONB discipline contains query
- ✅ Text search across fields
- ✅ Facets calculation
- ✅ Backward compat /decisions response shape
- ✅ Auth enforcement on all endpoints
- ✅ Role-based milestone toggle restriction
- ✅ Manual input auto-sets source_type
```

### Coverage Target
- 85%+
- Run: `cd decision-log-backend && python3 -m pytest tests/unit/test_project_items_api.py -v`

---

## Change Log

| Date | Change |
|------|--------|
| 2026-02-16 | Created story with architect review findings |

---

**Related Stories:** 5.1 (DB Migration), 5.3 (Frontend Types), 5.4 (AI Prompts)
**Blocked By:** 5.1 (Database migration must complete first)
**Co-dependent:** 5.3 (Frontend types must deploy together — Architect B5)
**Blocks:** 7.1 (Ingestion uses items API), 8.1 (Milestone Timeline reads milestones API)
