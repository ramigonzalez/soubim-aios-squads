# Story 3.5: Decision Timeline Component

**Story ID:** 3.5
**Assigned to:** @dev
**Sprint:** Sprint 5 (Week 7)
**Status:** Draft
**Estimation:** 8 story points (3-4 days)

---

## Summary

Build the decision timeline component that displays project decisions chronologically, grouped by meetings, with discipline badges, consensus indicators, and impact levels. Includes virtual scrolling for performance with 200+ decisions.

---

## Acceptance Criteria

- [ ] Fetch decisions from `/api/projects/{id}/decisions`
- [ ] Display decisions chronologically (oldest → newest, or newest → oldest toggle)
- [ ] Group decisions by meeting with meeting headers showing:
  - [ ] Meeting date
  - [ ] Meeting type badge (Client/Multi-disc/Internal)
  - [ ] Duration
  - [ ] Participant count
- [ ] Decision cards show:
  - [ ] Decision statement
  - [ ] Who made the decision
  - [ ] Timestamp in meeting
  - [ ] Discipline badge (colored: Architecture=Blue, MEP=Orange, etc.)
  - [ ] Consensus indicator (Green=Agree, Yellow=Mixed, Red=Dissent)
  - [ ] Impact level badge (High/Medium/Low)
  - [ ] Confidence score visual (0-100%)
- [ ] Virtual scrolling for 200+ decisions (performance <2s load)
- [ ] Click decision → Open drill-down modal (Story 3.7)
- [ ] Loading states with skeleton cards
- [ ] Empty state when no decisions exist
- [ ] Tests passing: `npm run test` (80%+ coverage)

---

## Tasks

### Task 1: Create Timeline Component Structure (1 day)

1. **Create `src/components/Timeline.tsx`**
   ```typescript
   import { useParams } from 'react-router-dom'
   import { useQuery } from '@tanstack/react-query'
   import { useState } from 'react'
   import { api } from '../services/api'
   import { Decision } from '../types'
   import { DecisionCard } from './DecisionCard'
   import { MeetingGroup } from './MeetingGroup'
   import { Alert, AlertDescription } from './ui/alert'
   import { Button } from './ui/button'
   import { getErrorMessage } from '../lib/errors'

   export function Timeline() {
     const { id: projectId } = useParams<{ id: string }>()
     const [selectedDecision, setSelectedDecision] = useState<Decision | null>(null)

     const {
       data: decisionsData,
       isLoading,
       isError,
       error,
       refetch
     } = useQuery({
       queryKey: ['decisions', projectId],
       queryFn: () => api.getDecisions(projectId!, {}),
       enabled: !!projectId,
     })

     if (isLoading) {
       return <TimelineSkeleton />
     }

     if (isError) {
       return (
         <Alert variant="destructive">
           <AlertDescription className="flex items-center justify-between">
             <span>{getErrorMessage(error)}</span>
             <Button variant="outline" size="sm" onClick={() => refetch()}>
               Retry
             </Button>
           </AlertDescription>
         </Alert>
       )
     }

     if (!decisionsData || decisionsData.decisions.length === 0) {
       return <EmptyTimeline />
     }

     // Group decisions by meeting
     const groupedByMeeting = groupDecisionsByMeeting(decisionsData.decisions)

     return (
       <div className="space-y-6">
         <div className="flex items-center justify-between mb-4">
           <h2 className="text-2xl font-bold">Decision Timeline</h2>
           <div className="text-sm text-gray-500">
             {decisionsData.total} decisions
           </div>
         </div>

         <div className="space-y-8">
           {Object.entries(groupedByMeeting).map(([meetingDate, decisions]) => (
             <MeetingGroup
               key={meetingDate}
               meetingDate={meetingDate}
               decisions={decisions}
               onDecisionClick={setSelectedDecision}
             />
           ))}
         </div>

         {selectedDecision && (
           <DrillDownModal
             decision={selectedDecision}
             onClose={() => setSelectedDecision(null)}
           />
         )}
       </div>
     )
   }

   function groupDecisionsByMeeting(decisions: Decision[]) {
     return decisions.reduce((acc, decision) => {
       const key = decision.meeting_date
       if (!acc[key]) acc[key] = []
       acc[key].push(decision)
       return acc
     }, {} as Record<string, Decision[]>)
   }

   function EmptyTimeline() {
     return (
       <div className="text-center py-12 border-2 border-dashed border-gray-300 rounded-lg">
         <h3 className="text-lg font-medium text-gray-900">No decisions yet</h3>
         <p className="mt-2 text-gray-500">
           Decisions will appear here once meetings are processed
         </p>
       </div>
     )
   }

   function TimelineSkeleton() {
     return (
       <div className="space-y-6">
         {[1, 2, 3].map((i) => (
           <div key={i} className="space-y-3">
             <div className="h-6 bg-gray-200 rounded animate-pulse w-1/4" />
             <div className="h-32 bg-gray-200 rounded animate-pulse" />
             <div className="h-32 bg-gray-200 rounded animate-pulse" />
           </div>
         ))}
       </div>
     )
   }
   ```

### Task 2: Create Meeting Group Component (0.75 days)

1. **Create `src/components/MeetingGroup.tsx`**
   ```typescript
   import { Decision } from '../types'
   import { DecisionCard } from './DecisionCard'
   import { formatDate } from '../lib/utils'
   import { Badge } from './ui/badge'
   import { Calendar, Clock, Users } from 'lucide-react'

   interface Props {
     meetingDate: string
     decisions: Decision[]
     onDecisionClick: (decision: Decision) => void
   }

   const MEETING_TYPE_COLORS = {
     client: 'bg-blue-100 text-blue-800',
     'multi-disciplinary': 'bg-purple-100 text-purple-800',
     internal: 'bg-gray-100 text-gray-800',
   }

   export function MeetingGroup({ meetingDate, decisions, onDecisionClick }: Props) {
     const firstDecision = decisions[0]
     const meetingType = firstDecision.meeting_type

     return (
       <div className="space-y-4">
         {/* Meeting Header */}
         <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
           <div className="flex items-center justify-between flex-wrap gap-4">
             <div className="flex items-center gap-4">
               <div className="flex items-center text-gray-700">
                 <Calendar className="h-4 w-4 mr-2" />
                 <span className="font-medium">{formatDate(meetingDate)}</span>
               </div>

               <Badge className={MEETING_TYPE_COLORS[meetingType as keyof typeof MEETING_TYPE_COLORS]}>
                 {meetingType}
               </Badge>
             </div>

             <div className="flex items-center gap-4 text-sm text-gray-600">
               <div className="flex items-center">
                 <Clock className="h-4 w-4 mr-1" />
                 <span>{decisions.length} decisions</span>
               </div>
             </div>
           </div>
         </div>

         {/* Decision Cards */}
         <div className="space-y-3 pl-4 border-l-2 border-gray-200">
           {decisions.map((decision) => (
             <DecisionCard
               key={decision.id}
               decision={decision}
               onClick={() => onDecisionClick(decision)}
             />
           ))}
         </div>
       </div>
     )
   }
   ```

2. **Install Shadcn badge component**
   ```bash
   npx shadcn-ui@latest add badge
   ```

### Task 3: Create Decision Card Component (1 day)

1. **Create `src/components/DecisionCard.tsx`**
   ```typescript
   import { Decision } from '../types'
   import { Badge } from './ui/badge'
   import { Card, CardContent } from './ui/card'
   import { ChevronRight } from 'lucide-react'

   interface Props {
     decision: Decision
     onClick: () => void
   }

   const DISCIPLINE_COLORS = {
     architecture: 'bg-blue-100 text-blue-800 border-blue-300',
     mep: 'bg-orange-100 text-orange-800 border-orange-300',
     landscape: 'bg-green-100 text-green-800 border-green-300',
     structural: 'bg-purple-100 text-purple-800 border-purple-300',
     electrical: 'bg-yellow-100 text-yellow-800 border-yellow-300',
     plumbing: 'bg-cyan-100 text-cyan-800 border-cyan-300',
     general: 'bg-gray-100 text-gray-800 border-gray-300',
   }

   const CONSENSUS_COLORS = {
     high: 'bg-green-100 text-green-800',
     medium: 'bg-yellow-100 text-yellow-800',
     low: 'bg-red-100 text-red-800',
   }

   const IMPACT_COLORS = {
     high: 'bg-red-100 text-red-800',
     medium: 'bg-yellow-100 text-yellow-800',
     low: 'bg-blue-100 text-blue-800',
   }

   export function DecisionCard({ decision, onClick }: Props) {
     const consensusLevel = getConsensusLevel(decision.consensus)
     const impactLevel = getImpactLevel(decision.impacts)

     return (
       <Card
         className="cursor-pointer hover:shadow-md transition-shadow"
         onClick={onClick}
       >
         <CardContent className="pt-6">
           <div className="flex items-start justify-between gap-4">
             <div className="flex-1">
               {/* Discipline Badge */}
               <Badge
                 variant="outline"
                 className={`mb-2 ${DISCIPLINE_COLORS[decision.discipline as keyof typeof DISCIPLINE_COLORS]}`}
               >
                 {decision.discipline}
               </Badge>

               {/* Decision Statement */}
               <h3 className="text-lg font-medium text-gray-900 mb-2">
                 {decision.decision_statement}
               </h3>

               {/* Metadata */}
               <div className="flex items-center gap-4 text-sm text-gray-600 mb-3">
                 <span>By {decision.who}</span>
                 <span>•</span>
                 <span>{decision.timestamp}</span>
               </div>

               {/* Badges Row */}
               <div className="flex items-center gap-2 flex-wrap">
                 <Badge className={CONSENSUS_COLORS[consensusLevel]}>
                   Consensus: {consensusLevel}
                 </Badge>

                 {impactLevel && (
                   <Badge className={IMPACT_COLORS[impactLevel]}>
                     Impact: {impactLevel}
                   </Badge>
                 )}

                 {decision.confidence && (
                   <Badge variant="outline">
                     {Math.round(decision.confidence * 100)}% confidence
                   </Badge>
                 )}

                 {decision.anomaly_flags && decision.anomaly_flags.length > 0 && (
                   <Badge variant="destructive">
                     ⚠ {decision.anomaly_flags.length} flags
                   </Badge>
                 )}
               </div>
             </div>

             <ChevronRight className="h-5 w-5 text-gray-400 flex-shrink-0" />
           </div>
         </CardContent>
       </Card>
     )
   }

   function getConsensusLevel(consensus: Record<string, string>): 'high' | 'medium' | 'low' {
     const values = Object.values(consensus)
     const agreeCount = values.filter((v) => v === 'AGREE').length
     const total = values.length

     if (agreeCount === total) return 'high'
     if (agreeCount >= total / 2) return 'medium'
     return 'low'
   }

   function getImpactLevel(impacts: any[]): 'high' | 'medium' | 'low' | null {
     if (!impacts || impacts.length === 0) return null

     // Simple heuristic: if timeline or budget impact mentioned, it's high
     const hasTimeline = impacts.some((i) => i.type === 'timeline')
     const hasBudget = impacts.some((i) => i.type === 'budget')

     if (hasTimeline && hasBudget) return 'high'
     if (hasTimeline || hasBudget) return 'medium'
     return 'low'
   }
   ```

### Task 4: Add Virtual Scrolling (Optional - Performance) (0.5 days)

1. **Install react-window for virtual scrolling**
   ```bash
   npm install react-window
   npm install -D @types/react-window
   ```

2. **Update Timeline to use virtual scrolling (if needed)**
   ```typescript
   // Only implement if >200 decisions in testing
   // For MVP, standard rendering is fine for <200 decisions
   import { FixedSizeList } from 'react-window'

   // Implement if performance testing shows >2s load time
   ```

### Task 5: Write Tests (0.75 days)

1. **Create `tests/components/Timeline.test.tsx`**
   ```typescript
   import { describe, it, expect, vi } from 'vitest'
   import { render, screen, waitFor } from '@testing-library/react'
   import { BrowserRouter, Routes, Route } from 'react-router-dom'
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
   import { Timeline } from '../../src/components/Timeline'
   import { api } from '../../src/services/api'

   vi.mock('../../src/services/api')

   const queryClient = new QueryClient({
     defaultOptions: { queries: { retry: false } },
   })

   const wrapper = ({ children }: { children: React.ReactNode }) => (
     <QueryClientProvider client={queryClient}>
       <BrowserRouter>
         <Routes>
           <Route path="/projects/:id" element={children} />
         </Routes>
       </BrowserRouter>
     </QueryClientProvider>
   )

   describe('Timeline', () => {
     it('displays decisions grouped by meeting', async () => {
       const mockDecisions = {
         decisions: [
           {
             id: '1',
             decision_statement: 'Changed material from concrete to steel',
             who: 'Carlos',
             timestamp: '00:23:15',
             discipline: 'structural',
             meeting_type: 'client',
             meeting_date: '2026-02-01T14:00:00Z',
             why: 'Client requirement',
             causation: 'client',
             impacts: [{ type: 'timeline', change: '+2 weeks' }],
             consensus: { architecture: 'AGREE', mep: 'AGREE' },
             confidence: 0.92,
             anomaly_flags: [],
             created_at: '2026-02-01T14:45:00Z',
           },
         ],
         total: 1,
         limit: 50,
         offset: 0,
       }

       vi.mocked(api.getDecisions).mockResolvedValue(mockDecisions)

       render(<Timeline />, { wrapper })

       await waitFor(() => {
         expect(screen.getByText('Changed material from concrete to steel')).toBeInTheDocument()
         expect(screen.getByText(/carlos/i)).toBeInTheDocument()
         expect(screen.getByText('structural')).toBeInTheDocument()
       })
     })

     it('displays empty state when no decisions', async () => {
       vi.mocked(api.getDecisions).mockResolvedValue({
         decisions: [],
         total: 0,
         limit: 50,
         offset: 0,
       })

       render(<Timeline />, { wrapper })

       await waitFor(() => {
         expect(screen.getByText(/no decisions yet/i)).toBeInTheDocument()
       })
     })
   })
   ```

---

## Dev Notes

### Timeline Architecture

```
Timeline Component
├── Fetch decisions from API
├── Group by meeting_date
└── For each meeting:
    ├── Meeting Header (date, type, count)
    └── Decision Cards
        ├── Discipline badge
        ├── Statement
        ├── Metadata (who, when)
        ├── Consensus indicator
        ├── Impact badge
        └── Confidence score
```

### Performance Considerations

- **Target**: <2 second load for 200 decisions
- **Optimization**: Virtual scrolling if >200 decisions
- **Caching**: React Query stale time 5 minutes
- **Lazy loading**: Load decisions on scroll (pagination)

### Color Coding System

| Element | Color | Meaning |
|---------|-------|---------|
| Architecture | Blue | Design decisions |
| MEP | Orange | Mechanical/Electrical/Plumbing |
| Landscape | Green | Landscape architecture |
| Structural | Purple | Structural engineering |
| High Consensus | Green | All agree |
| Medium Consensus | Yellow | Most agree |
| Low Consensus | Red | Significant dissent |
| High Impact | Red | Major timeline/budget impact |

---

## File List

**Modified/Created:**
- `src/components/Timeline.tsx` (new) - Main timeline component
- `src/components/MeetingGroup.tsx` (new) - Meeting group component
- `src/components/DecisionCard.tsx` (new) - Decision card component
- `tests/components/Timeline.test.tsx` (new) - Timeline tests
- `tests/components/DecisionCard.test.tsx` (new) - Card tests
- `package.json` (modify) - Add react-window (optional)

---

## Testing Strategy

### Unit Tests

```typescript
// Test coverage areas:
- ✅ Timeline rendering
- ✅ Decision grouping by meeting
- ✅ Meeting header display
- ✅ Decision card rendering
- ✅ Discipline color coding
- ✅ Consensus indicators
- ✅ Impact badges
- ✅ Empty state
- ✅ Loading state
- ✅ Error handling
```

### Performance Testing

```bash
# Test with 200+ decisions
npm run test:performance

# Measure load time
# Target: <2 seconds
```

### Coverage Target

- Minimum: 80%
- Target: 90%+
- Run: `npm run test -- --coverage`

---

## Change Log

| Date | Change |
|------|--------|
| 2026-02-08 | Created story |

---

**Related Stories:** 3.4 (Projects List), 3.6 (Filters), 3.7 (Drill-down)
**Blocked By:** 3.4
**Blocks:** 3.6 (filters need timeline), 3.7 (drill-down from timeline)
