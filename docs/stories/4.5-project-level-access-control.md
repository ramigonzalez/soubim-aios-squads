# Story 4.5: Project-Level Access Control

**Story ID:** 4.5
**Assigned to:** @dev
**Sprint:** Sprint 6 (Week 8)
**Status:** Draft
**Estimation:** 5 story points (2-3 days)

---

## Summary

Enforce project-level permissions using user_projects table to ensure users can only access projects they're assigned to, with automatic inheritance for decisions and nested resources.

---

## Acceptance Criteria

- [ ] Project access middleware created
- [ ] Access checks on all project endpoints:
  - [ ] GET /api/projects/{id}
  - [ ] GET /api/projects/{id}/decisions
  - [ ] GET /api/projects/{id}/digest
- [ ] Directors bypass checks (full access)
- [ ] Architects/clients filtered by user_projects
- [ ] Decision access inherits from project access
- [ ] Returns 403 if project not accessible
- [ ] Tests passing: `pytest tests/api/test_project_access.py`

---

## Tasks

### Task 1: Create Project Access Checker (1 day)

```python
# app/utils/project_access.py
def has_project_access(user: User, project_id: str, db: Session) -> bool:
    # Directors have access to all projects
    if user.role == "director":
        return True
    
    # Others must be assigned
    access = db.query(UserProject).filter(
        UserProject.user_id == user.id,
        UserProject.project_id == project_id
    ).first()
    
    return access is not None

def require_project_access(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        project_id = kwargs.get('project_id')
        request = kwargs.get('request') or args[0]
        db = kwargs.get('db')
        user = request.state.user
        
        if not has_project_access(user, project_id, db):
            raise HTTPException(status_code=403, detail="Access denied to project")
        
        return await func(*args, **kwargs)
    return wrapper
```

### Task 2: Apply to Endpoints (0.75 days)

```python
@router.get("/projects/{project_id}/decisions")
@require_project_access
async def list_decisions(
    project_id: str,
    request: Request,
    db: Session = Depends(get_db)
):
    # Access already validated by decorator
    decisions = db.query(Decision).filter(
        Decision.project_id == project_id
    ).all()
    return {"decisions": decisions}
```

### Task 3: Write Tests (0.75 days)

```python
def test_architect_can_access_assigned_project(client, architect_user, assigned_project):
    response = client.get(
        f"/api/projects/{assigned_project.id}/decisions",
        headers=auth_header(architect_user)
    )
    assert response.status_code == 200

def test_architect_cannot_access_unassigned_project(client, architect_user, other_project):
    response = client.get(
        f"/api/projects/{other_project.id}/decisions",
        headers=auth_header(architect_user)
    )
    assert response.status_code == 403
```

---

**Related Stories:** 4.4 (Role-Based Auth)
**Blocked By:** 4.4
**Blocks:** None
